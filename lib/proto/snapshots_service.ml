(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: snapshots_service.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[Google_types]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
open Google_types [@@warning "-33"]
(**/**)
module Imported'modules = struct
  module Struct = Struct
  module Timestamp = Timestamp
end
(**/**)
module Qdrant = struct
  module rec CreateFullSnapshotRequest : sig
    val name': unit -> string
    type t = unit 
    val make : unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "snapshots_service.qdrant.CreateFullSnapshotRequest"
    type t = unit
    let make =
      fun  () -> 
      
      ()
    
    let to_proto =
      let apply = fun ~f:f' () -> f' []  in
      let spec = Runtime'.Serialize.C.( nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions  -> () in
      let spec = Runtime'.Deserialize.C.( nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ListFullSnapshotsRequest : sig
    val name': unit -> string
    type t = unit 
    val make : unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "snapshots_service.qdrant.ListFullSnapshotsRequest"
    type t = unit
    let make =
      fun  () -> 
      
      ()
    
    let to_proto =
      let apply = fun ~f:f' () -> f' []  in
      let spec = Runtime'.Serialize.C.( nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions  -> () in
      let spec = Runtime'.Deserialize.C.( nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DeleteFullSnapshotRequest : sig
    val name': unit -> string
    type t = string 
    val make : ?snapshot_name:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "snapshots_service.qdrant.DeleteFullSnapshotRequest"
    type t = string
    let make =
      fun ?snapshot_name () -> 
      let snapshot_name = match snapshot_name with Some v -> v | None -> {||} in
      snapshot_name
    
    let to_proto =
      let apply = fun ~f:f' snapshot_name -> f' [] snapshot_name in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions snapshot_name -> snapshot_name in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateSnapshotRequest : sig
    val name': unit -> string
    type t = string 
    val make : ?collection_name:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "snapshots_service.qdrant.CreateSnapshotRequest"
    type t = string
    let make =
      fun ?collection_name () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      collection_name
    
    let to_proto =
      let apply = fun ~f:f' collection_name -> f' [] collection_name in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name -> collection_name in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ListSnapshotsRequest : sig
    val name': unit -> string
    type t = string 
    val make : ?collection_name:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "snapshots_service.qdrant.ListSnapshotsRequest"
    type t = string
    let make =
      fun ?collection_name () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      collection_name
    
    let to_proto =
      let apply = fun ~f:f' collection_name -> f' [] collection_name in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name -> collection_name in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DeleteSnapshotRequest : sig
    val name': unit -> string
    type t = { collection_name: string; snapshot_name: string } 
    val make : ?collection_name:string -> ?snapshot_name:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "snapshots_service.qdrant.DeleteSnapshotRequest"
    type t = { collection_name: string; snapshot_name: string }
    let make =
      fun ?collection_name ?snapshot_name () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      let snapshot_name = match snapshot_name with Some v -> v | None -> {||} in
      { collection_name; snapshot_name }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; snapshot_name } -> f' [] collection_name snapshot_name in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name snapshot_name -> { collection_name; snapshot_name } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and SnapshotDescription : sig
    val name': unit -> string
    type t = { name: string; creation_time: Imported'modules.Timestamp.Google.Protobuf.Timestamp.t option; size: int } 
    val make : ?name:string -> ?creation_time:Imported'modules.Timestamp.Google.Protobuf.Timestamp.t -> ?size:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "snapshots_service.qdrant.SnapshotDescription"
    type t = { name: string; creation_time: Imported'modules.Timestamp.Google.Protobuf.Timestamp.t option; size: int }
    let make =
      fun ?name ?creation_time ?size () -> 
      let name = match name with Some v -> v | None -> {||} in
      let size = match size with Some v -> v | None -> 0 in
      { name; creation_time; size }
    
    let to_proto =
      let apply = fun ~f:f' { name; creation_time; size } -> f' [] name creation_time size in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Imported'modules.Timestamp.Google.Protobuf.Timestamp.to_proto t))) ^:: basic (3, int64_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions name creation_time size -> { name; creation_time; size } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Imported'modules.Timestamp.Google.Protobuf.Timestamp.from_proto t))) ^:: basic (3, int64_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateSnapshotResponse : sig
    val name': unit -> string
    type t = { snapshot_description: SnapshotDescription.t option; time: float } 
    val make : ?snapshot_description:SnapshotDescription.t -> ?time:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "snapshots_service.qdrant.CreateSnapshotResponse"
    type t = { snapshot_description: SnapshotDescription.t option; time: float }
    let make =
      fun ?snapshot_description ?time () -> 
      let time = match time with Some v -> v | None -> 0. in
      { snapshot_description; time }
    
    let to_proto =
      let apply = fun ~f:f' { snapshot_description; time } -> f' [] snapshot_description time in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> SnapshotDescription.to_proto t))) ^:: basic (2, double, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions snapshot_description time -> { snapshot_description; time } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> SnapshotDescription.from_proto t))) ^:: basic (2, double, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ListSnapshotsResponse : sig
    val name': unit -> string
    type t = { snapshot_descriptions: SnapshotDescription.t list; time: float } 
    val make : ?snapshot_descriptions:SnapshotDescription.t list -> ?time:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "snapshots_service.qdrant.ListSnapshotsResponse"
    type t = { snapshot_descriptions: SnapshotDescription.t list; time: float }
    let make =
      fun ?snapshot_descriptions ?time () -> 
      let snapshot_descriptions = match snapshot_descriptions with Some v -> v | None -> [] in
      let time = match time with Some v -> v | None -> 0. in
      { snapshot_descriptions; time }
    
    let to_proto =
      let apply = fun ~f:f' { snapshot_descriptions; time } -> f' [] snapshot_descriptions time in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> SnapshotDescription.to_proto t)), not_packed) ^:: basic (2, double, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions snapshot_descriptions time -> { snapshot_descriptions; time } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> SnapshotDescription.from_proto t)), not_packed) ^:: basic (2, double, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DeleteSnapshotResponse : sig
    val name': unit -> string
    type t = float 
    val make : ?time:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "snapshots_service.qdrant.DeleteSnapshotResponse"
    type t = float
    let make =
      fun ?time () -> 
      let time = match time with Some v -> v | None -> 0. in
      time
    
    let to_proto =
      let apply = fun ~f:f' time -> f' [] time in
      let spec = Runtime'.Serialize.C.( basic (1, double, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions time -> time in
      let spec = Runtime'.Deserialize.C.( basic (1, double, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  module Snapshots = struct
    module Create = struct
      let name = "/qdrant.Snapshots/Create"
      module Request = CreateSnapshotRequest
      module Response = CreateSnapshotResponse
    end
    let create = 
      (module CreateSnapshotRequest : Runtime'.Service.Message with type t = CreateSnapshotRequest.t ), 
      (module CreateSnapshotResponse : Runtime'.Service.Message with type t = CreateSnapshotResponse.t )
    
    module List = struct
      let name = "/qdrant.Snapshots/List"
      module Request = ListSnapshotsRequest
      module Response = ListSnapshotsResponse
    end
    let list = 
      (module ListSnapshotsRequest : Runtime'.Service.Message with type t = ListSnapshotsRequest.t ), 
      (module ListSnapshotsResponse : Runtime'.Service.Message with type t = ListSnapshotsResponse.t )
    
    module Delete = struct
      let name = "/qdrant.Snapshots/Delete"
      module Request = DeleteSnapshotRequest
      module Response = DeleteSnapshotResponse
    end
    let delete = 
      (module DeleteSnapshotRequest : Runtime'.Service.Message with type t = DeleteSnapshotRequest.t ), 
      (module DeleteSnapshotResponse : Runtime'.Service.Message with type t = DeleteSnapshotResponse.t )
    
    module CreateFull = struct
      let name = "/qdrant.Snapshots/CreateFull"
      module Request = CreateFullSnapshotRequest
      module Response = CreateSnapshotResponse
    end
    let createFull = 
      (module CreateFullSnapshotRequest : Runtime'.Service.Message with type t = CreateFullSnapshotRequest.t ), 
      (module CreateSnapshotResponse : Runtime'.Service.Message with type t = CreateSnapshotResponse.t )
    
    module ListFull = struct
      let name = "/qdrant.Snapshots/ListFull"
      module Request = ListFullSnapshotsRequest
      module Response = ListSnapshotsResponse
    end
    let listFull = 
      (module ListFullSnapshotsRequest : Runtime'.Service.Message with type t = ListFullSnapshotsRequest.t ), 
      (module ListSnapshotsResponse : Runtime'.Service.Message with type t = ListSnapshotsResponse.t )
    
    module DeleteFull = struct
      let name = "/qdrant.Snapshots/DeleteFull"
      module Request = DeleteFullSnapshotRequest
      module Response = DeleteSnapshotResponse
    end
    let deleteFull = 
      (module DeleteFullSnapshotRequest : Runtime'.Service.Message with type t = DeleteFullSnapshotRequest.t ), 
      (module DeleteSnapshotResponse : Runtime'.Service.Message with type t = DeleteSnapshotResponse.t )
    
  end
end