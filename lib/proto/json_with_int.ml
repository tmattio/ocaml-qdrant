(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: json_with_int.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[Google_types]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
open Google_types [@@warning "-33"]
module Qdrant = struct
  module rec NullValue : sig
    type t = NULL_VALUE 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = NULL_VALUE 
    let to_int = function
      | NULL_VALUE -> 0
    
    let from_int = function
      | 0 -> Ok NULL_VALUE
      | n -> Error (`Unknown_enum_value n)
    
  end
  and Struct : sig
    module rec FieldsEntry : sig
      val name': unit -> string
      type t = (string * Value.t option) 
      val make : ?key:string -> ?value:Value.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end
    val name': unit -> string
    type t = Struct.FieldsEntry.t list 
    val make : ?fields:Struct.FieldsEntry.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    module rec FieldsEntry : sig
      val name': unit -> string
      type t = (string * Value.t option) 
      val make : ?key:string -> ?value:Value.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "json_with_int.qdrant.Struct.FieldsEntry"
      type t = (string * Value.t option)
      let make =
        fun ?key ?value () -> 
        let key = match key with Some v -> v | None -> {||} in
        (key, value)
      
      let to_proto =
        let apply = fun ~f:f' (key, value) -> f' [] key value in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Value.to_proto t))) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions key value -> (key, value) in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Value.from_proto t))) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    let name' () = "json_with_int.qdrant.Struct"
    type t = Struct.FieldsEntry.t list
    let make =
      fun ?fields () -> 
      let fields = match fields with Some v -> v | None -> [] in
      fields
    
    let to_proto =
      let apply = fun ~f:f' fields -> f' [] fields in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Struct.FieldsEntry.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions fields -> fields in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Struct.FieldsEntry.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and Value : sig
    val name': unit -> string
    type t = [ `not_set | `Null_value of NullValue.t | `Double_value of float | `Integer_value of int | `String_value of string | `Bool_value of bool | `Struct_value of Struct.t | `List_value of ListValue.t ] 
    val make : ?kind:[ `not_set | `Null_value of NullValue.t | `Double_value of float | `Integer_value of int | `String_value of string | `Bool_value of bool | `Struct_value of Struct.t | `List_value of ListValue.t ] -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "json_with_int.qdrant.Value"
    type t = [ `not_set | `Null_value of NullValue.t | `Double_value of float | `Integer_value of int | `String_value of string | `Bool_value of bool | `Struct_value of Struct.t | `List_value of ListValue.t ]
    let make =
      fun ?kind () -> 
      let kind = match kind with Some v -> v | None -> `not_set in
      kind
    
    let to_proto =
      let apply = fun ~f:f' kind -> f' [] kind in
      let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Null_value v -> oneof_elem (1, (enum NullValue.to_int), v) | `Double_value v -> oneof_elem (2, double, v) | `Integer_value v -> oneof_elem (3, int64_int, v) | `String_value v -> oneof_elem (4, string, v) | `Bool_value v -> oneof_elem (5, bool, v) | `Struct_value v -> oneof_elem (6, (message (fun t -> Struct.to_proto t)), v) | `List_value v -> oneof_elem (7, (message (fun t -> ListValue.to_proto t)), v))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions kind -> kind in
      let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (enum NullValue.from_int), fun v -> `Null_value v); oneof_elem (2, double, fun v -> `Double_value v); oneof_elem (3, int64_int, fun v -> `Integer_value v); oneof_elem (4, string, fun v -> `String_value v); oneof_elem (5, bool, fun v -> `Bool_value v); oneof_elem (6, (message (fun t -> Struct.from_proto t)), fun v -> `Struct_value v); oneof_elem (7, (message (fun t -> ListValue.from_proto t)), fun v -> `List_value v) ]) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ListValue : sig
    val name': unit -> string
    type t = Value.t list 
    val make : ?values:Value.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "json_with_int.qdrant.ListValue"
    type t = Value.t list
    let make =
      fun ?values () -> 
      let values = match values with Some v -> v | None -> [] in
      values
    
    let to_proto =
      let apply = fun ~f:f' values -> f' [] values in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Value.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions values -> values in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Value.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
end