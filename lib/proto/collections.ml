(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: collections.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[Google_types]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
open Google_types [@@warning "-33"]
module Qdrant = struct
  module rec Distance : sig
    type t = UnknownDistance | Cosine | Euclid | Dot 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = UnknownDistance | Cosine | Euclid | Dot 
    let to_int = function
      | UnknownDistance -> 0
      | Cosine -> 1
      | Euclid -> 2
      | Dot -> 3
    
    let from_int = function
      | 0 -> Ok UnknownDistance
      | 1 -> Ok Cosine
      | 2 -> Ok Euclid
      | 3 -> Ok Dot
      | n -> Error (`Unknown_enum_value n)
    
  end
  and CollectionStatus : sig
    type t = UnknownCollectionStatus | Green | Yellow | Red 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = UnknownCollectionStatus | Green | Yellow | Red 
    let to_int = function
      | UnknownCollectionStatus -> 0
      | Green -> 1
      | Yellow -> 2
      | Red -> 3
    
    let from_int = function
      | 0 -> Ok UnknownCollectionStatus
      | 1 -> Ok Green
      | 2 -> Ok Yellow
      | 3 -> Ok Red
      | n -> Error (`Unknown_enum_value n)
    
  end
  and PayloadSchemaType : sig
    type t = UnknownType | Keyword | Integer | Float | Geo | Text 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = UnknownType | Keyword | Integer | Float | Geo | Text 
    let to_int = function
      | UnknownType -> 0
      | Keyword -> 1
      | Integer -> 2
      | Float -> 3
      | Geo -> 4
      | Text -> 5
    
    let from_int = function
      | 0 -> Ok UnknownType
      | 1 -> Ok Keyword
      | 2 -> Ok Integer
      | 3 -> Ok Float
      | 4 -> Ok Geo
      | 5 -> Ok Text
      | n -> Error (`Unknown_enum_value n)
    
  end
  and QuantizationType : sig
    type t = UnknownQuantization | Int8 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = UnknownQuantization | Int8 
    let to_int = function
      | UnknownQuantization -> 0
      | Int8 -> 1
    
    let from_int = function
      | 0 -> Ok UnknownQuantization
      | 1 -> Ok Int8
      | n -> Error (`Unknown_enum_value n)
    
  end
  and CompressionRatio : sig
    type t = X4 | X8 | X16 | X32 | X64 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = X4 | X8 | X16 | X32 | X64 
    let to_int = function
      | X4 -> 0
      | X8 -> 1
      | X16 -> 2
      | X32 -> 3
      | X64 -> 4
    
    let from_int = function
      | 0 -> Ok X4
      | 1 -> Ok X8
      | 2 -> Ok X16
      | 3 -> Ok X32
      | 4 -> Ok X64
      | n -> Error (`Unknown_enum_value n)
    
  end
  and TokenizerType : sig
    type t = Unknown | Prefix | Whitespace | Word 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = Unknown | Prefix | Whitespace | Word 
    let to_int = function
      | Unknown -> 0
      | Prefix -> 1
      | Whitespace -> 2
      | Word -> 3
    
    let from_int = function
      | 0 -> Ok Unknown
      | 1 -> Ok Prefix
      | 2 -> Ok Whitespace
      | 3 -> Ok Word
      | n -> Error (`Unknown_enum_value n)
    
  end
  and ReplicaState : sig
    type t = Active | Dead | Partial | Initializing | Listener 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = Active | Dead | Partial | Initializing | Listener 
    let to_int = function
      | Active -> 0
      | Dead -> 1
      | Partial -> 2
      | Initializing -> 3
      | Listener -> 4
    
    let from_int = function
      | 0 -> Ok Active
      | 1 -> Ok Dead
      | 2 -> Ok Partial
      | 3 -> Ok Initializing
      | 4 -> Ok Listener
      | n -> Error (`Unknown_enum_value n)
    
  end
  and VectorParams : sig
    val name': unit -> string
    type t = { size: int; distance: Distance.t; hnsw_config: HnswConfigDiff.t option; quantization_config: QuantizationConfig.t option; on_disk: bool option } 
    val make : ?size:int -> ?distance:Distance.t -> ?hnsw_config:HnswConfigDiff.t -> ?quantization_config:QuantizationConfig.t -> ?on_disk:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.VectorParams"
    type t = { size: int; distance: Distance.t; hnsw_config: HnswConfigDiff.t option; quantization_config: QuantizationConfig.t option; on_disk: bool option }
    let make =
      fun ?size ?distance ?hnsw_config ?quantization_config ?on_disk () -> 
      let size = match size with Some v -> v | None -> 0 in
      let distance = match distance with Some v -> v | None -> (Distance.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { size; distance; hnsw_config; quantization_config; on_disk }
    
    let to_proto =
      let apply = fun ~f:f' { size; distance; hnsw_config; quantization_config; on_disk } -> f' [] size distance hnsw_config quantization_config on_disk in
      let spec = Runtime'.Serialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, (enum Distance.to_int), proto3) ^:: basic_opt (3, (message (fun t -> HnswConfigDiff.to_proto t))) ^:: basic_opt (4, (message (fun t -> QuantizationConfig.to_proto t))) ^:: basic_opt (5, bool) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions size distance hnsw_config quantization_config on_disk -> { size; distance; hnsw_config; quantization_config; on_disk } in
      let spec = Runtime'.Deserialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, (enum Distance.from_int), proto3) ^:: basic_opt (3, (message (fun t -> HnswConfigDiff.from_proto t))) ^:: basic_opt (4, (message (fun t -> QuantizationConfig.from_proto t))) ^:: basic_opt (5, bool) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and VectorParamsMap : sig
    module rec MapEntry : sig
      val name': unit -> string
      type t = (string * VectorParams.t option) 
      val make : ?key:string -> ?value:VectorParams.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end
    val name': unit -> string
    type t = VectorParamsMap.MapEntry.t list 
    val make : ?map:VectorParamsMap.MapEntry.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    module rec MapEntry : sig
      val name': unit -> string
      type t = (string * VectorParams.t option) 
      val make : ?key:string -> ?value:VectorParams.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "collections.qdrant.VectorParamsMap.MapEntry"
      type t = (string * VectorParams.t option)
      let make =
        fun ?key ?value () -> 
        let key = match key with Some v -> v | None -> {||} in
        (key, value)
      
      let to_proto =
        let apply = fun ~f:f' (key, value) -> f' [] key value in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> VectorParams.to_proto t))) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions key value -> (key, value) in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> VectorParams.from_proto t))) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    let name' () = "collections.qdrant.VectorParamsMap"
    type t = VectorParamsMap.MapEntry.t list
    let make =
      fun ?map () -> 
      let map = match map with Some v -> v | None -> [] in
      map
    
    let to_proto =
      let apply = fun ~f:f' map -> f' [] map in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> VectorParamsMap.MapEntry.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions map -> map in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> VectorParamsMap.MapEntry.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and VectorsConfig : sig
    val name': unit -> string
    type t = [ `not_set | `Params of VectorParams.t | `Params_map of VectorParamsMap.t ] 
    val make : ?config:[ `not_set | `Params of VectorParams.t | `Params_map of VectorParamsMap.t ] -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.VectorsConfig"
    type t = [ `not_set | `Params of VectorParams.t | `Params_map of VectorParamsMap.t ]
    let make =
      fun ?config () -> 
      let config = match config with Some v -> v | None -> `not_set in
      config
    
    let to_proto =
      let apply = fun ~f:f' config -> f' [] config in
      let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Params v -> oneof_elem (1, (message (fun t -> VectorParams.to_proto t)), v) | `Params_map v -> oneof_elem (2, (message (fun t -> VectorParamsMap.to_proto t)), v))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions config -> config in
      let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> VectorParams.from_proto t)), fun v -> `Params v); oneof_elem (2, (message (fun t -> VectorParamsMap.from_proto t)), fun v -> `Params_map v) ]) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and GetCollectionInfoRequest : sig
    val name': unit -> string
    type t = string 
    val make : ?collection_name:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.GetCollectionInfoRequest"
    type t = string
    let make =
      fun ?collection_name () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      collection_name
    
    let to_proto =
      let apply = fun ~f:f' collection_name -> f' [] collection_name in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name -> collection_name in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ListCollectionsRequest : sig
    val name': unit -> string
    type t = unit 
    val make : unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.ListCollectionsRequest"
    type t = unit
    let make =
      fun  () -> 
      
      ()
    
    let to_proto =
      let apply = fun ~f:f' () -> f' []  in
      let spec = Runtime'.Serialize.C.( nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions  -> () in
      let spec = Runtime'.Deserialize.C.( nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CollectionDescription : sig
    val name': unit -> string
    type t = string 
    val make : ?name:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.CollectionDescription"
    type t = string
    let make =
      fun ?name () -> 
      let name = match name with Some v -> v | None -> {||} in
      name
    
    let to_proto =
      let apply = fun ~f:f' name -> f' [] name in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions name -> name in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and GetCollectionInfoResponse : sig
    val name': unit -> string
    type t = { result: CollectionInfo.t option; time: float } 
    val make : ?result:CollectionInfo.t -> ?time:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.GetCollectionInfoResponse"
    type t = { result: CollectionInfo.t option; time: float }
    let make =
      fun ?result ?time () -> 
      let time = match time with Some v -> v | None -> 0. in
      { result; time }
    
    let to_proto =
      let apply = fun ~f:f' { result; time } -> f' [] result time in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> CollectionInfo.to_proto t))) ^:: basic (2, double, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions result time -> { result; time } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> CollectionInfo.from_proto t))) ^:: basic (2, double, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ListCollectionsResponse : sig
    val name': unit -> string
    type t = { collections: CollectionDescription.t list; time: float } 
    val make : ?collections:CollectionDescription.t list -> ?time:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.ListCollectionsResponse"
    type t = { collections: CollectionDescription.t list; time: float }
    let make =
      fun ?collections ?time () -> 
      let collections = match collections with Some v -> v | None -> [] in
      let time = match time with Some v -> v | None -> 0. in
      { collections; time }
    
    let to_proto =
      let apply = fun ~f:f' { collections; time } -> f' [] collections time in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> CollectionDescription.to_proto t)), not_packed) ^:: basic (2, double, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collections time -> { collections; time } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> CollectionDescription.from_proto t)), not_packed) ^:: basic (2, double, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and OptimizerStatus : sig
    val name': unit -> string
    type t = { ok: bool; error: string } 
    val make : ?ok:bool -> ?error:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.OptimizerStatus"
    type t = { ok: bool; error: string }
    let make =
      fun ?ok ?error () -> 
      let ok = match ok with Some v -> v | None -> false in
      let error = match error with Some v -> v | None -> {||} in
      { ok; error }
    
    let to_proto =
      let apply = fun ~f:f' { ok; error } -> f' [] ok error in
      let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions ok error -> { ok; error } in
      let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and HnswConfigDiff : sig
    val name': unit -> string
    type t = { m: int option; ef_construct: int option; full_scan_threshold: int option; max_indexing_threads: int option; on_disk: bool option; payload_m: int option } 
    val make : ?m:int -> ?ef_construct:int -> ?full_scan_threshold:int -> ?max_indexing_threads:int -> ?on_disk:bool -> ?payload_m:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.HnswConfigDiff"
    type t = { m: int option; ef_construct: int option; full_scan_threshold: int option; max_indexing_threads: int option; on_disk: bool option; payload_m: int option }
    let make =
      fun ?m ?ef_construct ?full_scan_threshold ?max_indexing_threads ?on_disk ?payload_m () -> 
      
      { m; ef_construct; full_scan_threshold; max_indexing_threads; on_disk; payload_m }
    
    let to_proto =
      let apply = fun ~f:f' { m; ef_construct; full_scan_threshold; max_indexing_threads; on_disk; payload_m } -> f' [] m ef_construct full_scan_threshold max_indexing_threads on_disk payload_m in
      let spec = Runtime'.Serialize.C.( basic_opt (1, uint64_int) ^:: basic_opt (2, uint64_int) ^:: basic_opt (3, uint64_int) ^:: basic_opt (4, uint64_int) ^:: basic_opt (5, bool) ^:: basic_opt (6, uint64_int) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions m ef_construct full_scan_threshold max_indexing_threads on_disk payload_m -> { m; ef_construct; full_scan_threshold; max_indexing_threads; on_disk; payload_m } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, uint64_int) ^:: basic_opt (2, uint64_int) ^:: basic_opt (3, uint64_int) ^:: basic_opt (4, uint64_int) ^:: basic_opt (5, bool) ^:: basic_opt (6, uint64_int) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and WalConfigDiff : sig
    val name': unit -> string
    type t = { wal_capacity_mb: int option; wal_segments_ahead: int option } 
    val make : ?wal_capacity_mb:int -> ?wal_segments_ahead:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.WalConfigDiff"
    type t = { wal_capacity_mb: int option; wal_segments_ahead: int option }
    let make =
      fun ?wal_capacity_mb ?wal_segments_ahead () -> 
      
      { wal_capacity_mb; wal_segments_ahead }
    
    let to_proto =
      let apply = fun ~f:f' { wal_capacity_mb; wal_segments_ahead } -> f' [] wal_capacity_mb wal_segments_ahead in
      let spec = Runtime'.Serialize.C.( basic_opt (1, uint64_int) ^:: basic_opt (2, uint64_int) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions wal_capacity_mb wal_segments_ahead -> { wal_capacity_mb; wal_segments_ahead } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, uint64_int) ^:: basic_opt (2, uint64_int) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and OptimizersConfigDiff : sig
    val name': unit -> string
    type t = { deleted_threshold: float option; vacuum_min_vector_number: int option; default_segment_number: int option; max_segment_size: int option; memmap_threshold: int option; indexing_threshold: int option; flush_interval_sec: int option; max_optimization_threads: int option } 
    val make : ?deleted_threshold:float -> ?vacuum_min_vector_number:int -> ?default_segment_number:int -> ?max_segment_size:int -> ?memmap_threshold:int -> ?indexing_threshold:int -> ?flush_interval_sec:int -> ?max_optimization_threads:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.OptimizersConfigDiff"
    type t = { deleted_threshold: float option; vacuum_min_vector_number: int option; default_segment_number: int option; max_segment_size: int option; memmap_threshold: int option; indexing_threshold: int option; flush_interval_sec: int option; max_optimization_threads: int option }
    let make =
      fun ?deleted_threshold ?vacuum_min_vector_number ?default_segment_number ?max_segment_size ?memmap_threshold ?indexing_threshold ?flush_interval_sec ?max_optimization_threads () -> 
      
      { deleted_threshold; vacuum_min_vector_number; default_segment_number; max_segment_size; memmap_threshold; indexing_threshold; flush_interval_sec; max_optimization_threads }
    
    let to_proto =
      let apply = fun ~f:f' { deleted_threshold; vacuum_min_vector_number; default_segment_number; max_segment_size; memmap_threshold; indexing_threshold; flush_interval_sec; max_optimization_threads } -> f' [] deleted_threshold vacuum_min_vector_number default_segment_number max_segment_size memmap_threshold indexing_threshold flush_interval_sec max_optimization_threads in
      let spec = Runtime'.Serialize.C.( basic_opt (1, double) ^:: basic_opt (2, uint64_int) ^:: basic_opt (3, uint64_int) ^:: basic_opt (4, uint64_int) ^:: basic_opt (5, uint64_int) ^:: basic_opt (6, uint64_int) ^:: basic_opt (7, uint64_int) ^:: basic_opt (8, uint64_int) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions deleted_threshold vacuum_min_vector_number default_segment_number max_segment_size memmap_threshold indexing_threshold flush_interval_sec max_optimization_threads -> { deleted_threshold; vacuum_min_vector_number; default_segment_number; max_segment_size; memmap_threshold; indexing_threshold; flush_interval_sec; max_optimization_threads } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, double) ^:: basic_opt (2, uint64_int) ^:: basic_opt (3, uint64_int) ^:: basic_opt (4, uint64_int) ^:: basic_opt (5, uint64_int) ^:: basic_opt (6, uint64_int) ^:: basic_opt (7, uint64_int) ^:: basic_opt (8, uint64_int) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ScalarQuantization : sig
    val name': unit -> string
    type t = { type': QuantizationType.t; quantile: float option; always_ram: bool option } 
    val make : ?type':QuantizationType.t -> ?quantile:float -> ?always_ram:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.ScalarQuantization"
    type t = { type': QuantizationType.t; quantile: float option; always_ram: bool option }
    let make =
      fun ?type' ?quantile ?always_ram () -> 
      let type' = match type' with Some v -> v | None -> (QuantizationType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { type'; quantile; always_ram }
    
    let to_proto =
      let apply = fun ~f:f' { type'; quantile; always_ram } -> f' [] type' quantile always_ram in
      let spec = Runtime'.Serialize.C.( basic (1, (enum QuantizationType.to_int), proto3) ^:: basic_opt (2, float) ^:: basic_opt (3, bool) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions type' quantile always_ram -> { type'; quantile; always_ram } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum QuantizationType.from_int), proto3) ^:: basic_opt (2, float) ^:: basic_opt (3, bool) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ProductQuantization : sig
    val name': unit -> string
    type t = { compression: CompressionRatio.t; always_ram: bool option } 
    val make : ?compression:CompressionRatio.t -> ?always_ram:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.ProductQuantization"
    type t = { compression: CompressionRatio.t; always_ram: bool option }
    let make =
      fun ?compression ?always_ram () -> 
      let compression = match compression with Some v -> v | None -> (CompressionRatio.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { compression; always_ram }
    
    let to_proto =
      let apply = fun ~f:f' { compression; always_ram } -> f' [] compression always_ram in
      let spec = Runtime'.Serialize.C.( basic (1, (enum CompressionRatio.to_int), proto3) ^:: basic_opt (2, bool) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions compression always_ram -> { compression; always_ram } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum CompressionRatio.from_int), proto3) ^:: basic_opt (2, bool) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and QuantizationConfig : sig
    val name': unit -> string
    type t = [ `not_set | `Scalar of ScalarQuantization.t | `Product of ProductQuantization.t ] 
    val make : ?quantization:[ `not_set | `Scalar of ScalarQuantization.t | `Product of ProductQuantization.t ] -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.QuantizationConfig"
    type t = [ `not_set | `Scalar of ScalarQuantization.t | `Product of ProductQuantization.t ]
    let make =
      fun ?quantization () -> 
      let quantization = match quantization with Some v -> v | None -> `not_set in
      quantization
    
    let to_proto =
      let apply = fun ~f:f' quantization -> f' [] quantization in
      let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Scalar v -> oneof_elem (1, (message (fun t -> ScalarQuantization.to_proto t)), v) | `Product v -> oneof_elem (2, (message (fun t -> ProductQuantization.to_proto t)), v))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions quantization -> quantization in
      let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> ScalarQuantization.from_proto t)), fun v -> `Scalar v); oneof_elem (2, (message (fun t -> ProductQuantization.from_proto t)), fun v -> `Product v) ]) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateCollection : sig
    val name': unit -> string
    type t = { collection_name: string; hnsw_config: HnswConfigDiff.t option; wal_config: WalConfigDiff.t option; optimizers_config: OptimizersConfigDiff.t option; shard_number: int option; on_disk_payload: bool option; timeout: int option; vectors_config: VectorsConfig.t option; replication_factor: int option; write_consistency_factor: int option; init_from_collection: string option; quantization_config: QuantizationConfig.t option } 
    val make : ?collection_name:string -> ?hnsw_config:HnswConfigDiff.t -> ?wal_config:WalConfigDiff.t -> ?optimizers_config:OptimizersConfigDiff.t -> ?shard_number:int -> ?on_disk_payload:bool -> ?timeout:int -> ?vectors_config:VectorsConfig.t -> ?replication_factor:int -> ?write_consistency_factor:int -> ?init_from_collection:string -> ?quantization_config:QuantizationConfig.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.CreateCollection"
    type t = { collection_name: string; hnsw_config: HnswConfigDiff.t option; wal_config: WalConfigDiff.t option; optimizers_config: OptimizersConfigDiff.t option; shard_number: int option; on_disk_payload: bool option; timeout: int option; vectors_config: VectorsConfig.t option; replication_factor: int option; write_consistency_factor: int option; init_from_collection: string option; quantization_config: QuantizationConfig.t option }
    let make =
      fun ?collection_name ?hnsw_config ?wal_config ?optimizers_config ?shard_number ?on_disk_payload ?timeout ?vectors_config ?replication_factor ?write_consistency_factor ?init_from_collection ?quantization_config () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      { collection_name; hnsw_config; wal_config; optimizers_config; shard_number; on_disk_payload; timeout; vectors_config; replication_factor; write_consistency_factor; init_from_collection; quantization_config }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; hnsw_config; wal_config; optimizers_config; shard_number; on_disk_payload; timeout; vectors_config; replication_factor; write_consistency_factor; init_from_collection; quantization_config } -> f' [] collection_name hnsw_config wal_config optimizers_config shard_number on_disk_payload timeout vectors_config replication_factor write_consistency_factor init_from_collection quantization_config in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (4, (message (fun t -> HnswConfigDiff.to_proto t))) ^:: basic_opt (5, (message (fun t -> WalConfigDiff.to_proto t))) ^:: basic_opt (6, (message (fun t -> OptimizersConfigDiff.to_proto t))) ^:: basic_opt (7, uint32_int) ^:: basic_opt (8, bool) ^:: basic_opt (9, uint64_int) ^:: basic_opt (10, (message (fun t -> VectorsConfig.to_proto t))) ^:: basic_opt (11, uint32_int) ^:: basic_opt (12, uint32_int) ^:: basic_opt (13, string) ^:: basic_opt (14, (message (fun t -> QuantizationConfig.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name hnsw_config wal_config optimizers_config shard_number on_disk_payload timeout vectors_config replication_factor write_consistency_factor init_from_collection quantization_config -> { collection_name; hnsw_config; wal_config; optimizers_config; shard_number; on_disk_payload; timeout; vectors_config; replication_factor; write_consistency_factor; init_from_collection; quantization_config } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (4, (message (fun t -> HnswConfigDiff.from_proto t))) ^:: basic_opt (5, (message (fun t -> WalConfigDiff.from_proto t))) ^:: basic_opt (6, (message (fun t -> OptimizersConfigDiff.from_proto t))) ^:: basic_opt (7, uint32_int) ^:: basic_opt (8, bool) ^:: basic_opt (9, uint64_int) ^:: basic_opt (10, (message (fun t -> VectorsConfig.from_proto t))) ^:: basic_opt (11, uint32_int) ^:: basic_opt (12, uint32_int) ^:: basic_opt (13, string) ^:: basic_opt (14, (message (fun t -> QuantizationConfig.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and UpdateCollection : sig
    val name': unit -> string
    type t = { collection_name: string; optimizers_config: OptimizersConfigDiff.t option; timeout: int option; params: CollectionParamsDiff.t option } 
    val make : ?collection_name:string -> ?optimizers_config:OptimizersConfigDiff.t -> ?timeout:int -> ?params:CollectionParamsDiff.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.UpdateCollection"
    type t = { collection_name: string; optimizers_config: OptimizersConfigDiff.t option; timeout: int option; params: CollectionParamsDiff.t option }
    let make =
      fun ?collection_name ?optimizers_config ?timeout ?params () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      { collection_name; optimizers_config; timeout; params }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; optimizers_config; timeout; params } -> f' [] collection_name optimizers_config timeout params in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> OptimizersConfigDiff.to_proto t))) ^:: basic_opt (3, uint64_int) ^:: basic_opt (4, (message (fun t -> CollectionParamsDiff.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name optimizers_config timeout params -> { collection_name; optimizers_config; timeout; params } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> OptimizersConfigDiff.from_proto t))) ^:: basic_opt (3, uint64_int) ^:: basic_opt (4, (message (fun t -> CollectionParamsDiff.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DeleteCollection : sig
    val name': unit -> string
    type t = { collection_name: string; timeout: int option } 
    val make : ?collection_name:string -> ?timeout:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.DeleteCollection"
    type t = { collection_name: string; timeout: int option }
    let make =
      fun ?collection_name ?timeout () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      { collection_name; timeout }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; timeout } -> f' [] collection_name timeout in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, uint64_int) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name timeout -> { collection_name; timeout } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, uint64_int) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CollectionOperationResponse : sig
    val name': unit -> string
    type t = { result: bool; time: float } 
    val make : ?result:bool -> ?time:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.CollectionOperationResponse"
    type t = { result: bool; time: float }
    let make =
      fun ?result ?time () -> 
      let result = match result with Some v -> v | None -> false in
      let time = match time with Some v -> v | None -> 0. in
      { result; time }
    
    let to_proto =
      let apply = fun ~f:f' { result; time } -> f' [] result time in
      let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: basic (2, double, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions result time -> { result; time } in
      let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: basic (2, double, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CollectionParams : sig
    val name': unit -> string
    type t = { shard_number: int; on_disk_payload: bool; vectors_config: VectorsConfig.t option; replication_factor: int option; write_consistency_factor: int option } 
    val make : ?shard_number:int -> ?on_disk_payload:bool -> ?vectors_config:VectorsConfig.t -> ?replication_factor:int -> ?write_consistency_factor:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.CollectionParams"
    type t = { shard_number: int; on_disk_payload: bool; vectors_config: VectorsConfig.t option; replication_factor: int option; write_consistency_factor: int option }
    let make =
      fun ?shard_number ?on_disk_payload ?vectors_config ?replication_factor ?write_consistency_factor () -> 
      let shard_number = match shard_number with Some v -> v | None -> 0 in
      let on_disk_payload = match on_disk_payload with Some v -> v | None -> false in
      { shard_number; on_disk_payload; vectors_config; replication_factor; write_consistency_factor }
    
    let to_proto =
      let apply = fun ~f:f' { shard_number; on_disk_payload; vectors_config; replication_factor; write_consistency_factor } -> f' [] shard_number on_disk_payload vectors_config replication_factor write_consistency_factor in
      let spec = Runtime'.Serialize.C.( basic (3, uint32_int, proto3) ^:: basic (4, bool, proto3) ^:: basic_opt (5, (message (fun t -> VectorsConfig.to_proto t))) ^:: basic_opt (6, uint32_int) ^:: basic_opt (7, uint32_int) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions shard_number on_disk_payload vectors_config replication_factor write_consistency_factor -> { shard_number; on_disk_payload; vectors_config; replication_factor; write_consistency_factor } in
      let spec = Runtime'.Deserialize.C.( basic (3, uint32_int, proto3) ^:: basic (4, bool, proto3) ^:: basic_opt (5, (message (fun t -> VectorsConfig.from_proto t))) ^:: basic_opt (6, uint32_int) ^:: basic_opt (7, uint32_int) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CollectionParamsDiff : sig
    val name': unit -> string
    type t = { replication_factor: int option; write_consistency_factor: int option } 
    val make : ?replication_factor:int -> ?write_consistency_factor:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.CollectionParamsDiff"
    type t = { replication_factor: int option; write_consistency_factor: int option }
    let make =
      fun ?replication_factor ?write_consistency_factor () -> 
      
      { replication_factor; write_consistency_factor }
    
    let to_proto =
      let apply = fun ~f:f' { replication_factor; write_consistency_factor } -> f' [] replication_factor write_consistency_factor in
      let spec = Runtime'.Serialize.C.( basic_opt (1, uint32_int) ^:: basic_opt (2, uint32_int) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions replication_factor write_consistency_factor -> { replication_factor; write_consistency_factor } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, uint32_int) ^:: basic_opt (2, uint32_int) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CollectionConfig : sig
    val name': unit -> string
    type t = { params: CollectionParams.t option; hnsw_config: HnswConfigDiff.t option; optimizer_config: OptimizersConfigDiff.t option; wal_config: WalConfigDiff.t option; quantization_config: QuantizationConfig.t option } 
    val make : ?params:CollectionParams.t -> ?hnsw_config:HnswConfigDiff.t -> ?optimizer_config:OptimizersConfigDiff.t -> ?wal_config:WalConfigDiff.t -> ?quantization_config:QuantizationConfig.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.CollectionConfig"
    type t = { params: CollectionParams.t option; hnsw_config: HnswConfigDiff.t option; optimizer_config: OptimizersConfigDiff.t option; wal_config: WalConfigDiff.t option; quantization_config: QuantizationConfig.t option }
    let make =
      fun ?params ?hnsw_config ?optimizer_config ?wal_config ?quantization_config () -> 
      
      { params; hnsw_config; optimizer_config; wal_config; quantization_config }
    
    let to_proto =
      let apply = fun ~f:f' { params; hnsw_config; optimizer_config; wal_config; quantization_config } -> f' [] params hnsw_config optimizer_config wal_config quantization_config in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> CollectionParams.to_proto t))) ^:: basic_opt (2, (message (fun t -> HnswConfigDiff.to_proto t))) ^:: basic_opt (3, (message (fun t -> OptimizersConfigDiff.to_proto t))) ^:: basic_opt (4, (message (fun t -> WalConfigDiff.to_proto t))) ^:: basic_opt (5, (message (fun t -> QuantizationConfig.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions params hnsw_config optimizer_config wal_config quantization_config -> { params; hnsw_config; optimizer_config; wal_config; quantization_config } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> CollectionParams.from_proto t))) ^:: basic_opt (2, (message (fun t -> HnswConfigDiff.from_proto t))) ^:: basic_opt (3, (message (fun t -> OptimizersConfigDiff.from_proto t))) ^:: basic_opt (4, (message (fun t -> WalConfigDiff.from_proto t))) ^:: basic_opt (5, (message (fun t -> QuantizationConfig.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and TextIndexParams : sig
    val name': unit -> string
    type t = { tokenizer: TokenizerType.t; lowercase: bool option; min_token_len: int option; max_token_len: int option } 
    val make : ?tokenizer:TokenizerType.t -> ?lowercase:bool -> ?min_token_len:int -> ?max_token_len:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.TextIndexParams"
    type t = { tokenizer: TokenizerType.t; lowercase: bool option; min_token_len: int option; max_token_len: int option }
    let make =
      fun ?tokenizer ?lowercase ?min_token_len ?max_token_len () -> 
      let tokenizer = match tokenizer with Some v -> v | None -> (TokenizerType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { tokenizer; lowercase; min_token_len; max_token_len }
    
    let to_proto =
      let apply = fun ~f:f' { tokenizer; lowercase; min_token_len; max_token_len } -> f' [] tokenizer lowercase min_token_len max_token_len in
      let spec = Runtime'.Serialize.C.( basic (1, (enum TokenizerType.to_int), proto3) ^:: basic_opt (2, bool) ^:: basic_opt (3, uint64_int) ^:: basic_opt (4, uint64_int) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions tokenizer lowercase min_token_len max_token_len -> { tokenizer; lowercase; min_token_len; max_token_len } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum TokenizerType.from_int), proto3) ^:: basic_opt (2, bool) ^:: basic_opt (3, uint64_int) ^:: basic_opt (4, uint64_int) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and PayloadIndexParams : sig
    val name': unit -> string
    type t = [ `not_set | `Text_index_params of TextIndexParams.t ] 
    val make : ?index_params:[ `not_set | `Text_index_params of TextIndexParams.t ] -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.PayloadIndexParams"
    type t = [ `not_set | `Text_index_params of TextIndexParams.t ]
    let make =
      fun ?index_params () -> 
      let index_params = match index_params with Some v -> v | None -> `not_set in
      index_params
    
    let to_proto =
      let apply = fun ~f:f' index_params -> f' [] index_params in
      let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Text_index_params v -> oneof_elem (1, (message (fun t -> TextIndexParams.to_proto t)), v))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions index_params -> index_params in
      let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> TextIndexParams.from_proto t)), fun v -> `Text_index_params v) ]) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and PayloadSchemaInfo : sig
    val name': unit -> string
    type t = { data_type: PayloadSchemaType.t; params: PayloadIndexParams.t option; points: int option } 
    val make : ?data_type:PayloadSchemaType.t -> ?params:PayloadIndexParams.t -> ?points:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.PayloadSchemaInfo"
    type t = { data_type: PayloadSchemaType.t; params: PayloadIndexParams.t option; points: int option }
    let make =
      fun ?data_type ?params ?points () -> 
      let data_type = match data_type with Some v -> v | None -> (PayloadSchemaType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { data_type; params; points }
    
    let to_proto =
      let apply = fun ~f:f' { data_type; params; points } -> f' [] data_type params points in
      let spec = Runtime'.Serialize.C.( basic (1, (enum PayloadSchemaType.to_int), proto3) ^:: basic_opt (2, (message (fun t -> PayloadIndexParams.to_proto t))) ^:: basic_opt (3, uint64_int) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions data_type params points -> { data_type; params; points } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum PayloadSchemaType.from_int), proto3) ^:: basic_opt (2, (message (fun t -> PayloadIndexParams.from_proto t))) ^:: basic_opt (3, uint64_int) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CollectionInfo : sig
    module rec PayloadSchemaEntry : sig
      val name': unit -> string
      type t = (string * PayloadSchemaInfo.t option) 
      val make : ?key:string -> ?value:PayloadSchemaInfo.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end
    val name': unit -> string
    type t = { status: CollectionStatus.t; optimizer_status: OptimizerStatus.t option; vectors_count: int; segments_count: int; config: CollectionConfig.t option; payload_schema: CollectionInfo.PayloadSchemaEntry.t list; points_count: int; indexed_vectors_count: int option } 
    val make : ?status:CollectionStatus.t -> ?optimizer_status:OptimizerStatus.t -> ?vectors_count:int -> ?segments_count:int -> ?config:CollectionConfig.t -> ?payload_schema:CollectionInfo.PayloadSchemaEntry.t list -> ?points_count:int -> ?indexed_vectors_count:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    module rec PayloadSchemaEntry : sig
      val name': unit -> string
      type t = (string * PayloadSchemaInfo.t option) 
      val make : ?key:string -> ?value:PayloadSchemaInfo.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "collections.qdrant.CollectionInfo.PayloadSchemaEntry"
      type t = (string * PayloadSchemaInfo.t option)
      let make =
        fun ?key ?value () -> 
        let key = match key with Some v -> v | None -> {||} in
        (key, value)
      
      let to_proto =
        let apply = fun ~f:f' (key, value) -> f' [] key value in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> PayloadSchemaInfo.to_proto t))) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions key value -> (key, value) in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> PayloadSchemaInfo.from_proto t))) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    let name' () = "collections.qdrant.CollectionInfo"
    type t = { status: CollectionStatus.t; optimizer_status: OptimizerStatus.t option; vectors_count: int; segments_count: int; config: CollectionConfig.t option; payload_schema: CollectionInfo.PayloadSchemaEntry.t list; points_count: int; indexed_vectors_count: int option }
    let make =
      fun ?status ?optimizer_status ?vectors_count ?segments_count ?config ?payload_schema ?points_count ?indexed_vectors_count () -> 
      let status = match status with Some v -> v | None -> (CollectionStatus.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let vectors_count = match vectors_count with Some v -> v | None -> 0 in
      let segments_count = match segments_count with Some v -> v | None -> 0 in
      let payload_schema = match payload_schema with Some v -> v | None -> [] in
      let points_count = match points_count with Some v -> v | None -> 0 in
      { status; optimizer_status; vectors_count; segments_count; config; payload_schema; points_count; indexed_vectors_count }
    
    let to_proto =
      let apply = fun ~f:f' { status; optimizer_status; vectors_count; segments_count; config; payload_schema; points_count; indexed_vectors_count } -> f' [] status optimizer_status vectors_count segments_count config payload_schema points_count indexed_vectors_count in
      let spec = Runtime'.Serialize.C.( basic (1, (enum CollectionStatus.to_int), proto3) ^:: basic_opt (2, (message (fun t -> OptimizerStatus.to_proto t))) ^:: basic (3, uint64_int, proto3) ^:: basic (4, uint64_int, proto3) ^:: basic_opt (7, (message (fun t -> CollectionConfig.to_proto t))) ^:: repeated (8, (message (fun t -> CollectionInfo.PayloadSchemaEntry.to_proto t)), not_packed) ^:: basic (9, uint64_int, proto3) ^:: basic_opt (10, uint64_int) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions status optimizer_status vectors_count segments_count config payload_schema points_count indexed_vectors_count -> { status; optimizer_status; vectors_count; segments_count; config; payload_schema; points_count; indexed_vectors_count } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum CollectionStatus.from_int), proto3) ^:: basic_opt (2, (message (fun t -> OptimizerStatus.from_proto t))) ^:: basic (3, uint64_int, proto3) ^:: basic (4, uint64_int, proto3) ^:: basic_opt (7, (message (fun t -> CollectionConfig.from_proto t))) ^:: repeated (8, (message (fun t -> CollectionInfo.PayloadSchemaEntry.from_proto t)), not_packed) ^:: basic (9, uint64_int, proto3) ^:: basic_opt (10, uint64_int) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ChangeAliases : sig
    val name': unit -> string
    type t = { actions: AliasOperations.t list; timeout: int option } 
    val make : ?actions:AliasOperations.t list -> ?timeout:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.ChangeAliases"
    type t = { actions: AliasOperations.t list; timeout: int option }
    let make =
      fun ?actions ?timeout () -> 
      let actions = match actions with Some v -> v | None -> [] in
      { actions; timeout }
    
    let to_proto =
      let apply = fun ~f:f' { actions; timeout } -> f' [] actions timeout in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> AliasOperations.to_proto t)), not_packed) ^:: basic_opt (2, uint64_int) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions actions timeout -> { actions; timeout } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> AliasOperations.from_proto t)), not_packed) ^:: basic_opt (2, uint64_int) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AliasOperations : sig
    val name': unit -> string
    type t = [ `not_set | `Create_alias of CreateAlias.t | `Rename_alias of RenameAlias.t | `Delete_alias of DeleteAlias.t ] 
    val make : ?action:[ `not_set | `Create_alias of CreateAlias.t | `Rename_alias of RenameAlias.t | `Delete_alias of DeleteAlias.t ] -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.AliasOperations"
    type t = [ `not_set | `Create_alias of CreateAlias.t | `Rename_alias of RenameAlias.t | `Delete_alias of DeleteAlias.t ]
    let make =
      fun ?action () -> 
      let action = match action with Some v -> v | None -> `not_set in
      action
    
    let to_proto =
      let apply = fun ~f:f' action -> f' [] action in
      let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Create_alias v -> oneof_elem (1, (message (fun t -> CreateAlias.to_proto t)), v) | `Rename_alias v -> oneof_elem (2, (message (fun t -> RenameAlias.to_proto t)), v) | `Delete_alias v -> oneof_elem (3, (message (fun t -> DeleteAlias.to_proto t)), v))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions action -> action in
      let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> CreateAlias.from_proto t)), fun v -> `Create_alias v); oneof_elem (2, (message (fun t -> RenameAlias.from_proto t)), fun v -> `Rename_alias v); oneof_elem (3, (message (fun t -> DeleteAlias.from_proto t)), fun v -> `Delete_alias v) ]) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateAlias : sig
    val name': unit -> string
    type t = { collection_name: string; alias_name: string } 
    val make : ?collection_name:string -> ?alias_name:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.CreateAlias"
    type t = { collection_name: string; alias_name: string }
    let make =
      fun ?collection_name ?alias_name () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      let alias_name = match alias_name with Some v -> v | None -> {||} in
      { collection_name; alias_name }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; alias_name } -> f' [] collection_name alias_name in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name alias_name -> { collection_name; alias_name } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RenameAlias : sig
    val name': unit -> string
    type t = { old_alias_name: string; new_alias_name: string } 
    val make : ?old_alias_name:string -> ?new_alias_name:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.RenameAlias"
    type t = { old_alias_name: string; new_alias_name: string }
    let make =
      fun ?old_alias_name ?new_alias_name () -> 
      let old_alias_name = match old_alias_name with Some v -> v | None -> {||} in
      let new_alias_name = match new_alias_name with Some v -> v | None -> {||} in
      { old_alias_name; new_alias_name }
    
    let to_proto =
      let apply = fun ~f:f' { old_alias_name; new_alias_name } -> f' [] old_alias_name new_alias_name in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions old_alias_name new_alias_name -> { old_alias_name; new_alias_name } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DeleteAlias : sig
    val name': unit -> string
    type t = string 
    val make : ?alias_name:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.DeleteAlias"
    type t = string
    let make =
      fun ?alias_name () -> 
      let alias_name = match alias_name with Some v -> v | None -> {||} in
      alias_name
    
    let to_proto =
      let apply = fun ~f:f' alias_name -> f' [] alias_name in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions alias_name -> alias_name in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ListAliasesRequest : sig
    val name': unit -> string
    type t = unit 
    val make : unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.ListAliasesRequest"
    type t = unit
    let make =
      fun  () -> 
      
      ()
    
    let to_proto =
      let apply = fun ~f:f' () -> f' []  in
      let spec = Runtime'.Serialize.C.( nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions  -> () in
      let spec = Runtime'.Deserialize.C.( nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ListCollectionAliasesRequest : sig
    val name': unit -> string
    type t = string 
    val make : ?collection_name:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.ListCollectionAliasesRequest"
    type t = string
    let make =
      fun ?collection_name () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      collection_name
    
    let to_proto =
      let apply = fun ~f:f' collection_name -> f' [] collection_name in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name -> collection_name in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AliasDescription : sig
    val name': unit -> string
    type t = { alias_name: string; collection_name: string } 
    val make : ?alias_name:string -> ?collection_name:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.AliasDescription"
    type t = { alias_name: string; collection_name: string }
    let make =
      fun ?alias_name ?collection_name () -> 
      let alias_name = match alias_name with Some v -> v | None -> {||} in
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      { alias_name; collection_name }
    
    let to_proto =
      let apply = fun ~f:f' { alias_name; collection_name } -> f' [] alias_name collection_name in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions alias_name collection_name -> { alias_name; collection_name } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ListAliasesResponse : sig
    val name': unit -> string
    type t = { aliases: AliasDescription.t list; time: float } 
    val make : ?aliases:AliasDescription.t list -> ?time:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.ListAliasesResponse"
    type t = { aliases: AliasDescription.t list; time: float }
    let make =
      fun ?aliases ?time () -> 
      let aliases = match aliases with Some v -> v | None -> [] in
      let time = match time with Some v -> v | None -> 0. in
      { aliases; time }
    
    let to_proto =
      let apply = fun ~f:f' { aliases; time } -> f' [] aliases time in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> AliasDescription.to_proto t)), not_packed) ^:: basic (2, double, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions aliases time -> { aliases; time } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> AliasDescription.from_proto t)), not_packed) ^:: basic (2, double, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CollectionClusterInfoRequest : sig
    val name': unit -> string
    type t = string 
    val make : ?collection_name:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.CollectionClusterInfoRequest"
    type t = string
    let make =
      fun ?collection_name () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      collection_name
    
    let to_proto =
      let apply = fun ~f:f' collection_name -> f' [] collection_name in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name -> collection_name in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and LocalShardInfo : sig
    val name': unit -> string
    type t = { shard_id: int; points_count: int; state: ReplicaState.t } 
    val make : ?shard_id:int -> ?points_count:int -> ?state:ReplicaState.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.LocalShardInfo"
    type t = { shard_id: int; points_count: int; state: ReplicaState.t }
    let make =
      fun ?shard_id ?points_count ?state () -> 
      let shard_id = match shard_id with Some v -> v | None -> 0 in
      let points_count = match points_count with Some v -> v | None -> 0 in
      let state = match state with Some v -> v | None -> (ReplicaState.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { shard_id; points_count; state }
    
    let to_proto =
      let apply = fun ~f:f' { shard_id; points_count; state } -> f' [] shard_id points_count state in
      let spec = Runtime'.Serialize.C.( basic (1, uint32_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: basic (3, (enum ReplicaState.to_int), proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions shard_id points_count state -> { shard_id; points_count; state } in
      let spec = Runtime'.Deserialize.C.( basic (1, uint32_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: basic (3, (enum ReplicaState.from_int), proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RemoteShardInfo : sig
    val name': unit -> string
    type t = { shard_id: int; peer_id: int; state: ReplicaState.t } 
    val make : ?shard_id:int -> ?peer_id:int -> ?state:ReplicaState.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.RemoteShardInfo"
    type t = { shard_id: int; peer_id: int; state: ReplicaState.t }
    let make =
      fun ?shard_id ?peer_id ?state () -> 
      let shard_id = match shard_id with Some v -> v | None -> 0 in
      let peer_id = match peer_id with Some v -> v | None -> 0 in
      let state = match state with Some v -> v | None -> (ReplicaState.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { shard_id; peer_id; state }
    
    let to_proto =
      let apply = fun ~f:f' { shard_id; peer_id; state } -> f' [] shard_id peer_id state in
      let spec = Runtime'.Serialize.C.( basic (1, uint32_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: basic (3, (enum ReplicaState.to_int), proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions shard_id peer_id state -> { shard_id; peer_id; state } in
      let spec = Runtime'.Deserialize.C.( basic (1, uint32_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: basic (3, (enum ReplicaState.from_int), proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ShardTransferInfo : sig
    val name': unit -> string
    type t = { shard_id: int; from: int; to': int; sync: bool } 
    val make : ?shard_id:int -> ?from:int -> ?to':int -> ?sync:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.ShardTransferInfo"
    type t = { shard_id: int; from: int; to': int; sync: bool }
    let make =
      fun ?shard_id ?from ?to' ?sync () -> 
      let shard_id = match shard_id with Some v -> v | None -> 0 in
      let from = match from with Some v -> v | None -> 0 in
      let to' = match to' with Some v -> v | None -> 0 in
      let sync = match sync with Some v -> v | None -> false in
      { shard_id; from; to'; sync }
    
    let to_proto =
      let apply = fun ~f:f' { shard_id; from; to'; sync } -> f' [] shard_id from to' sync in
      let spec = Runtime'.Serialize.C.( basic (1, uint32_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: basic (3, uint64_int, proto3) ^:: basic (4, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions shard_id from to' sync -> { shard_id; from; to'; sync } in
      let spec = Runtime'.Deserialize.C.( basic (1, uint32_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: basic (3, uint64_int, proto3) ^:: basic (4, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CollectionClusterInfoResponse : sig
    val name': unit -> string
    type t = { peer_id: int; shard_count: int; local_shards: LocalShardInfo.t list; remote_shards: RemoteShardInfo.t list; shard_transfers: ShardTransferInfo.t list } 
    val make : ?peer_id:int -> ?shard_count:int -> ?local_shards:LocalShardInfo.t list -> ?remote_shards:RemoteShardInfo.t list -> ?shard_transfers:ShardTransferInfo.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.CollectionClusterInfoResponse"
    type t = { peer_id: int; shard_count: int; local_shards: LocalShardInfo.t list; remote_shards: RemoteShardInfo.t list; shard_transfers: ShardTransferInfo.t list }
    let make =
      fun ?peer_id ?shard_count ?local_shards ?remote_shards ?shard_transfers () -> 
      let peer_id = match peer_id with Some v -> v | None -> 0 in
      let shard_count = match shard_count with Some v -> v | None -> 0 in
      let local_shards = match local_shards with Some v -> v | None -> [] in
      let remote_shards = match remote_shards with Some v -> v | None -> [] in
      let shard_transfers = match shard_transfers with Some v -> v | None -> [] in
      { peer_id; shard_count; local_shards; remote_shards; shard_transfers }
    
    let to_proto =
      let apply = fun ~f:f' { peer_id; shard_count; local_shards; remote_shards; shard_transfers } -> f' [] peer_id shard_count local_shards remote_shards shard_transfers in
      let spec = Runtime'.Serialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: repeated (3, (message (fun t -> LocalShardInfo.to_proto t)), not_packed) ^:: repeated (4, (message (fun t -> RemoteShardInfo.to_proto t)), not_packed) ^:: repeated (5, (message (fun t -> ShardTransferInfo.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions peer_id shard_count local_shards remote_shards shard_transfers -> { peer_id; shard_count; local_shards; remote_shards; shard_transfers } in
      let spec = Runtime'.Deserialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: repeated (3, (message (fun t -> LocalShardInfo.from_proto t)), not_packed) ^:: repeated (4, (message (fun t -> RemoteShardInfo.from_proto t)), not_packed) ^:: repeated (5, (message (fun t -> ShardTransferInfo.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and MoveShard : sig
    val name': unit -> string
    type t = { shard_id: int; from_peer_id: int; to_peer_id: int } 
    val make : ?shard_id:int -> ?from_peer_id:int -> ?to_peer_id:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.MoveShard"
    type t = { shard_id: int; from_peer_id: int; to_peer_id: int }
    let make =
      fun ?shard_id ?from_peer_id ?to_peer_id () -> 
      let shard_id = match shard_id with Some v -> v | None -> 0 in
      let from_peer_id = match from_peer_id with Some v -> v | None -> 0 in
      let to_peer_id = match to_peer_id with Some v -> v | None -> 0 in
      { shard_id; from_peer_id; to_peer_id }
    
    let to_proto =
      let apply = fun ~f:f' { shard_id; from_peer_id; to_peer_id } -> f' [] shard_id from_peer_id to_peer_id in
      let spec = Runtime'.Serialize.C.( basic (1, uint32_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: basic (3, uint64_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions shard_id from_peer_id to_peer_id -> { shard_id; from_peer_id; to_peer_id } in
      let spec = Runtime'.Deserialize.C.( basic (1, uint32_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: basic (3, uint64_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and Replica : sig
    val name': unit -> string
    type t = { shard_id: int; peer_id: int } 
    val make : ?shard_id:int -> ?peer_id:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.Replica"
    type t = { shard_id: int; peer_id: int }
    let make =
      fun ?shard_id ?peer_id () -> 
      let shard_id = match shard_id with Some v -> v | None -> 0 in
      let peer_id = match peer_id with Some v -> v | None -> 0 in
      { shard_id; peer_id }
    
    let to_proto =
      let apply = fun ~f:f' { shard_id; peer_id } -> f' [] shard_id peer_id in
      let spec = Runtime'.Serialize.C.( basic (1, uint32_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions shard_id peer_id -> { shard_id; peer_id } in
      let spec = Runtime'.Deserialize.C.( basic (1, uint32_int, proto3) ^:: basic (2, uint64_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and UpdateCollectionClusterSetupRequest : sig
    val name': unit -> string
    type t = { collection_name: string; operation: [ `not_set | `Move_shard of MoveShard.t | `Replicate_shard of MoveShard.t | `Abort_transfer of MoveShard.t | `Drop_replica of Replica.t ]; timeout: int option } 
    val make : ?collection_name:string -> ?operation:[ `not_set | `Move_shard of MoveShard.t | `Replicate_shard of MoveShard.t | `Abort_transfer of MoveShard.t | `Drop_replica of Replica.t ] -> ?timeout:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.UpdateCollectionClusterSetupRequest"
    type t = { collection_name: string; operation: [ `not_set | `Move_shard of MoveShard.t | `Replicate_shard of MoveShard.t | `Abort_transfer of MoveShard.t | `Drop_replica of Replica.t ]; timeout: int option }
    let make =
      fun ?collection_name ?operation ?timeout () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      let operation = match operation with Some v -> v | None -> `not_set in
      { collection_name; operation; timeout }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; operation; timeout } -> f' [] collection_name operation timeout in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Move_shard v -> oneof_elem (2, (message (fun t -> MoveShard.to_proto t)), v) | `Replicate_shard v -> oneof_elem (3, (message (fun t -> MoveShard.to_proto t)), v) | `Abort_transfer v -> oneof_elem (4, (message (fun t -> MoveShard.to_proto t)), v) | `Drop_replica v -> oneof_elem (5, (message (fun t -> Replica.to_proto t)), v))) ^:: basic_opt (6, uint64_int) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name operation timeout -> { collection_name; operation; timeout } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: oneof ([ oneof_elem (2, (message (fun t -> MoveShard.from_proto t)), fun v -> `Move_shard v); oneof_elem (3, (message (fun t -> MoveShard.from_proto t)), fun v -> `Replicate_shard v); oneof_elem (4, (message (fun t -> MoveShard.from_proto t)), fun v -> `Abort_transfer v); oneof_elem (5, (message (fun t -> Replica.from_proto t)), fun v -> `Drop_replica v) ]) ^:: basic_opt (6, uint64_int) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and UpdateCollectionClusterSetupResponse : sig
    val name': unit -> string
    type t = bool 
    val make : ?result:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "collections.qdrant.UpdateCollectionClusterSetupResponse"
    type t = bool
    let make =
      fun ?result () -> 
      let result = match result with Some v -> v | None -> false in
      result
    
    let to_proto =
      let apply = fun ~f:f' result -> f' [] result in
      let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions result -> result in
      let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
end