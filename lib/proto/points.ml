(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: points.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[Google_types]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
open Google_types [@@warning "-33"]
(**/**)
module Imported'modules = struct
  module Json_with_int = Json_with_int
  module Collections = Collections
end
(**/**)
module Qdrant = struct
  module rec WriteOrderingType : sig
    type t = Weak | Medium | Strong 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = Weak | Medium | Strong 
    let to_int = function
      | Weak -> 0
      | Medium -> 1
      | Strong -> 2
    
    let from_int = function
      | 0 -> Ok Weak
      | 1 -> Ok Medium
      | 2 -> Ok Strong
      | n -> Error (`Unknown_enum_value n)
    
  end
  and ReadConsistencyType : sig
    type t = All | Majority | Quorum 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = All | Majority | Quorum 
    let to_int = function
      | All -> 0
      | Majority -> 1
      | Quorum -> 2
    
    let from_int = function
      | 0 -> Ok All
      | 1 -> Ok Majority
      | 2 -> Ok Quorum
      | n -> Error (`Unknown_enum_value n)
    
  end
  and FieldType : sig
    type t = FieldTypeKeyword | FieldTypeInteger | FieldTypeFloat | FieldTypeGeo | FieldTypeText 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = FieldTypeKeyword | FieldTypeInteger | FieldTypeFloat | FieldTypeGeo | FieldTypeText 
    let to_int = function
      | FieldTypeKeyword -> 0
      | FieldTypeInteger -> 1
      | FieldTypeFloat -> 2
      | FieldTypeGeo -> 3
      | FieldTypeText -> 4
    
    let from_int = function
      | 0 -> Ok FieldTypeKeyword
      | 1 -> Ok FieldTypeInteger
      | 2 -> Ok FieldTypeFloat
      | 3 -> Ok FieldTypeGeo
      | 4 -> Ok FieldTypeText
      | n -> Error (`Unknown_enum_value n)
    
  end
  and UpdateStatus : sig
    type t = UnknownUpdateStatus | Acknowledged | Completed 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = UnknownUpdateStatus | Acknowledged | Completed 
    let to_int = function
      | UnknownUpdateStatus -> 0
      | Acknowledged -> 1
      | Completed -> 2
    
    let from_int = function
      | 0 -> Ok UnknownUpdateStatus
      | 1 -> Ok Acknowledged
      | 2 -> Ok Completed
      | n -> Error (`Unknown_enum_value n)
    
  end
  and WriteOrdering : sig
    val name': unit -> string
    type t = WriteOrderingType.t 
    val make : ?type':WriteOrderingType.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.WriteOrdering"
    type t = WriteOrderingType.t
    let make =
      fun ?type' () -> 
      let type' = match type' with Some v -> v | None -> (WriteOrderingType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      type'
    
    let to_proto =
      let apply = fun ~f:f' type' -> f' [] type' in
      let spec = Runtime'.Serialize.C.( basic (1, (enum WriteOrderingType.to_int), proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions type' -> type' in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum WriteOrderingType.from_int), proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ReadConsistency : sig
    val name': unit -> string
    type t = [ `not_set | `Type of ReadConsistencyType.t | `Factor of int ] 
    val make : ?value:[ `not_set | `Type of ReadConsistencyType.t | `Factor of int ] -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.ReadConsistency"
    type t = [ `not_set | `Type of ReadConsistencyType.t | `Factor of int ]
    let make =
      fun ?value () -> 
      let value = match value with Some v -> v | None -> `not_set in
      value
    
    let to_proto =
      let apply = fun ~f:f' value -> f' [] value in
      let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Type v -> oneof_elem (1, (enum ReadConsistencyType.to_int), v) | `Factor v -> oneof_elem (2, uint64_int, v))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions value -> value in
      let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (enum ReadConsistencyType.from_int), fun v -> `Type v); oneof_elem (2, uint64_int, fun v -> `Factor v) ]) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and PointId : sig
    val name': unit -> string
    type t = [ `not_set | `Num of int | `Uuid of string ] 
    val make : ?point_id_options:[ `not_set | `Num of int | `Uuid of string ] -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.PointId"
    type t = [ `not_set | `Num of int | `Uuid of string ]
    let make =
      fun ?point_id_options () -> 
      let point_id_options = match point_id_options with Some v -> v | None -> `not_set in
      point_id_options
    
    let to_proto =
      let apply = fun ~f:f' point_id_options -> f' [] point_id_options in
      let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Num v -> oneof_elem (1, uint64_int, v) | `Uuid v -> oneof_elem (2, string, v))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions point_id_options -> point_id_options in
      let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, uint64_int, fun v -> `Num v); oneof_elem (2, string, fun v -> `Uuid v) ]) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and Vector : sig
    val name': unit -> string
    type t = float list 
    val make : ?data:float list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.Vector"
    type t = float list
    let make =
      fun ?data () -> 
      let data = match data with Some v -> v | None -> [] in
      data
    
    let to_proto =
      let apply = fun ~f:f' data -> f' [] data in
      let spec = Runtime'.Serialize.C.( repeated (1, float, packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions data -> data in
      let spec = Runtime'.Deserialize.C.( repeated (1, float, packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and UpsertPoints : sig
    val name': unit -> string
    type t = { collection_name: string; wait: bool option; points: PointStruct.t list; ordering: WriteOrdering.t option } 
    val make : ?collection_name:string -> ?wait:bool -> ?points:PointStruct.t list -> ?ordering:WriteOrdering.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.UpsertPoints"
    type t = { collection_name: string; wait: bool option; points: PointStruct.t list; ordering: WriteOrdering.t option }
    let make =
      fun ?collection_name ?wait ?points ?ordering () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      let points = match points with Some v -> v | None -> [] in
      { collection_name; wait; points; ordering }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; wait; points; ordering } -> f' [] collection_name wait points ordering in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, bool) ^:: repeated (3, (message (fun t -> PointStruct.to_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> WriteOrdering.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name wait points ordering -> { collection_name; wait; points; ordering } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, bool) ^:: repeated (3, (message (fun t -> PointStruct.from_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> WriteOrdering.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DeletePoints : sig
    val name': unit -> string
    type t = { collection_name: string; wait: bool option; points: PointsSelector.t option; ordering: WriteOrdering.t option } 
    val make : ?collection_name:string -> ?wait:bool -> ?points:PointsSelector.t -> ?ordering:WriteOrdering.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.DeletePoints"
    type t = { collection_name: string; wait: bool option; points: PointsSelector.t option; ordering: WriteOrdering.t option }
    let make =
      fun ?collection_name ?wait ?points ?ordering () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      { collection_name; wait; points; ordering }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; wait; points; ordering } -> f' [] collection_name wait points ordering in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, bool) ^:: basic_opt (3, (message (fun t -> PointsSelector.to_proto t))) ^:: basic_opt (4, (message (fun t -> WriteOrdering.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name wait points ordering -> { collection_name; wait; points; ordering } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, bool) ^:: basic_opt (3, (message (fun t -> PointsSelector.from_proto t))) ^:: basic_opt (4, (message (fun t -> WriteOrdering.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and GetPoints : sig
    val name': unit -> string
    type t = { collection_name: string; ids: PointId.t list; with_payload: WithPayloadSelector.t option; with_vectors: WithVectorsSelector.t option; read_consistency: ReadConsistency.t option } 
    val make : ?collection_name:string -> ?ids:PointId.t list -> ?with_payload:WithPayloadSelector.t -> ?with_vectors:WithVectorsSelector.t -> ?read_consistency:ReadConsistency.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.GetPoints"
    type t = { collection_name: string; ids: PointId.t list; with_payload: WithPayloadSelector.t option; with_vectors: WithVectorsSelector.t option; read_consistency: ReadConsistency.t option }
    let make =
      fun ?collection_name ?ids ?with_payload ?with_vectors ?read_consistency () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      let ids = match ids with Some v -> v | None -> [] in
      { collection_name; ids; with_payload; with_vectors; read_consistency }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; ids; with_payload; with_vectors; read_consistency } -> f' [] collection_name ids with_payload with_vectors read_consistency in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> PointId.to_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> WithPayloadSelector.to_proto t))) ^:: basic_opt (5, (message (fun t -> WithVectorsSelector.to_proto t))) ^:: basic_opt (6, (message (fun t -> ReadConsistency.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name ids with_payload with_vectors read_consistency -> { collection_name; ids; with_payload; with_vectors; read_consistency } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> PointId.from_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> WithPayloadSelector.from_proto t))) ^:: basic_opt (5, (message (fun t -> WithVectorsSelector.from_proto t))) ^:: basic_opt (6, (message (fun t -> ReadConsistency.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and UpdatePointVectors : sig
    val name': unit -> string
    type t = { collection_name: string; wait: bool option; points: PointVectors.t list; ordering: WriteOrdering.t option } 
    val make : ?collection_name:string -> ?wait:bool -> ?points:PointVectors.t list -> ?ordering:WriteOrdering.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.UpdatePointVectors"
    type t = { collection_name: string; wait: bool option; points: PointVectors.t list; ordering: WriteOrdering.t option }
    let make =
      fun ?collection_name ?wait ?points ?ordering () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      let points = match points with Some v -> v | None -> [] in
      { collection_name; wait; points; ordering }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; wait; points; ordering } -> f' [] collection_name wait points ordering in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, bool) ^:: repeated (3, (message (fun t -> PointVectors.to_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> WriteOrdering.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name wait points ordering -> { collection_name; wait; points; ordering } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, bool) ^:: repeated (3, (message (fun t -> PointVectors.from_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> WriteOrdering.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and PointVectors : sig
    val name': unit -> string
    type t = { id: PointId.t option; vectors: Vectors.t option } 
    val make : ?id:PointId.t -> ?vectors:Vectors.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.PointVectors"
    type t = { id: PointId.t option; vectors: Vectors.t option }
    let make =
      fun ?id ?vectors () -> 
      
      { id; vectors }
    
    let to_proto =
      let apply = fun ~f:f' { id; vectors } -> f' [] id vectors in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> PointId.to_proto t))) ^:: basic_opt (2, (message (fun t -> Vectors.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions id vectors -> { id; vectors } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> PointId.from_proto t))) ^:: basic_opt (2, (message (fun t -> Vectors.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DeletePointVectors : sig
    val name': unit -> string
    type t = { collection_name: string; wait: bool option; points_selector: PointsSelector.t option; vectors: VectorsSelector.t option; ordering: WriteOrdering.t option } 
    val make : ?collection_name:string -> ?wait:bool -> ?points_selector:PointsSelector.t -> ?vectors:VectorsSelector.t -> ?ordering:WriteOrdering.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.DeletePointVectors"
    type t = { collection_name: string; wait: bool option; points_selector: PointsSelector.t option; vectors: VectorsSelector.t option; ordering: WriteOrdering.t option }
    let make =
      fun ?collection_name ?wait ?points_selector ?vectors ?ordering () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      { collection_name; wait; points_selector; vectors; ordering }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; wait; points_selector; vectors; ordering } -> f' [] collection_name wait points_selector vectors ordering in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, bool) ^:: basic_opt (3, (message (fun t -> PointsSelector.to_proto t))) ^:: basic_opt (4, (message (fun t -> VectorsSelector.to_proto t))) ^:: basic_opt (5, (message (fun t -> WriteOrdering.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name wait points_selector vectors ordering -> { collection_name; wait; points_selector; vectors; ordering } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, bool) ^:: basic_opt (3, (message (fun t -> PointsSelector.from_proto t))) ^:: basic_opt (4, (message (fun t -> VectorsSelector.from_proto t))) ^:: basic_opt (5, (message (fun t -> WriteOrdering.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and SetPayloadPoints : sig
    module rec PayloadEntry : sig
      val name': unit -> string
      type t = (string * Imported'modules.Json_with_int.Qdrant.Value.t option) 
      val make : ?key:string -> ?value:Imported'modules.Json_with_int.Qdrant.Value.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end
    val name': unit -> string
    type t = { collection_name: string; wait: bool option; payload: SetPayloadPoints.PayloadEntry.t list; points_selector: PointsSelector.t option; ordering: WriteOrdering.t option } 
    val make : ?collection_name:string -> ?wait:bool -> ?payload:SetPayloadPoints.PayloadEntry.t list -> ?points_selector:PointsSelector.t -> ?ordering:WriteOrdering.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    module rec PayloadEntry : sig
      val name': unit -> string
      type t = (string * Imported'modules.Json_with_int.Qdrant.Value.t option) 
      val make : ?key:string -> ?value:Imported'modules.Json_with_int.Qdrant.Value.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "points.qdrant.SetPayloadPoints.PayloadEntry"
      type t = (string * Imported'modules.Json_with_int.Qdrant.Value.t option)
      let make =
        fun ?key ?value () -> 
        let key = match key with Some v -> v | None -> {||} in
        (key, value)
      
      let to_proto =
        let apply = fun ~f:f' (key, value) -> f' [] key value in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Imported'modules.Json_with_int.Qdrant.Value.to_proto t))) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions key value -> (key, value) in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Imported'modules.Json_with_int.Qdrant.Value.from_proto t))) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    let name' () = "points.qdrant.SetPayloadPoints"
    type t = { collection_name: string; wait: bool option; payload: SetPayloadPoints.PayloadEntry.t list; points_selector: PointsSelector.t option; ordering: WriteOrdering.t option }
    let make =
      fun ?collection_name ?wait ?payload ?points_selector ?ordering () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      let payload = match payload with Some v -> v | None -> [] in
      { collection_name; wait; payload; points_selector; ordering }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; wait; payload; points_selector; ordering } -> f' [] collection_name wait payload points_selector ordering in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, bool) ^:: repeated (3, (message (fun t -> SetPayloadPoints.PayloadEntry.to_proto t)), not_packed) ^:: basic_opt (5, (message (fun t -> PointsSelector.to_proto t))) ^:: basic_opt (6, (message (fun t -> WriteOrdering.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name wait payload points_selector ordering -> { collection_name; wait; payload; points_selector; ordering } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, bool) ^:: repeated (3, (message (fun t -> SetPayloadPoints.PayloadEntry.from_proto t)), not_packed) ^:: basic_opt (5, (message (fun t -> PointsSelector.from_proto t))) ^:: basic_opt (6, (message (fun t -> WriteOrdering.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DeletePayloadPoints : sig
    val name': unit -> string
    type t = { collection_name: string; wait: bool option; keys: string list; points_selector: PointsSelector.t option; ordering: WriteOrdering.t option } 
    val make : ?collection_name:string -> ?wait:bool -> ?keys:string list -> ?points_selector:PointsSelector.t -> ?ordering:WriteOrdering.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.DeletePayloadPoints"
    type t = { collection_name: string; wait: bool option; keys: string list; points_selector: PointsSelector.t option; ordering: WriteOrdering.t option }
    let make =
      fun ?collection_name ?wait ?keys ?points_selector ?ordering () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      let keys = match keys with Some v -> v | None -> [] in
      { collection_name; wait; keys; points_selector; ordering }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; wait; keys; points_selector; ordering } -> f' [] collection_name wait keys points_selector ordering in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, bool) ^:: repeated (3, string, packed) ^:: basic_opt (5, (message (fun t -> PointsSelector.to_proto t))) ^:: basic_opt (6, (message (fun t -> WriteOrdering.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name wait keys points_selector ordering -> { collection_name; wait; keys; points_selector; ordering } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, bool) ^:: repeated (3, string, packed) ^:: basic_opt (5, (message (fun t -> PointsSelector.from_proto t))) ^:: basic_opt (6, (message (fun t -> WriteOrdering.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ClearPayloadPoints : sig
    val name': unit -> string
    type t = { collection_name: string; wait: bool option; points: PointsSelector.t option; ordering: WriteOrdering.t option } 
    val make : ?collection_name:string -> ?wait:bool -> ?points:PointsSelector.t -> ?ordering:WriteOrdering.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.ClearPayloadPoints"
    type t = { collection_name: string; wait: bool option; points: PointsSelector.t option; ordering: WriteOrdering.t option }
    let make =
      fun ?collection_name ?wait ?points ?ordering () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      { collection_name; wait; points; ordering }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; wait; points; ordering } -> f' [] collection_name wait points ordering in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, bool) ^:: basic_opt (3, (message (fun t -> PointsSelector.to_proto t))) ^:: basic_opt (4, (message (fun t -> WriteOrdering.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name wait points ordering -> { collection_name; wait; points; ordering } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, bool) ^:: basic_opt (3, (message (fun t -> PointsSelector.from_proto t))) ^:: basic_opt (4, (message (fun t -> WriteOrdering.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateFieldIndexCollection : sig
    val name': unit -> string
    type t = { collection_name: string; wait: bool option; field_name: string; field_type: FieldType.t option; field_index_params: Imported'modules.Collections.Qdrant.PayloadIndexParams.t option; ordering: WriteOrdering.t option } 
    val make : ?collection_name:string -> ?wait:bool -> ?field_name:string -> ?field_type:FieldType.t -> ?field_index_params:Imported'modules.Collections.Qdrant.PayloadIndexParams.t -> ?ordering:WriteOrdering.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.CreateFieldIndexCollection"
    type t = { collection_name: string; wait: bool option; field_name: string; field_type: FieldType.t option; field_index_params: Imported'modules.Collections.Qdrant.PayloadIndexParams.t option; ordering: WriteOrdering.t option }
    let make =
      fun ?collection_name ?wait ?field_name ?field_type ?field_index_params ?ordering () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      let field_name = match field_name with Some v -> v | None -> {||} in
      { collection_name; wait; field_name; field_type; field_index_params; ordering }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; wait; field_name; field_type; field_index_params; ordering } -> f' [] collection_name wait field_name field_type field_index_params ordering in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, bool) ^:: basic (3, string, proto3) ^:: basic_opt (4, (enum FieldType.to_int)) ^:: basic_opt (5, (message (fun t -> Imported'modules.Collections.Qdrant.PayloadIndexParams.to_proto t))) ^:: basic_opt (6, (message (fun t -> WriteOrdering.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name wait field_name field_type field_index_params ordering -> { collection_name; wait; field_name; field_type; field_index_params; ordering } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, bool) ^:: basic (3, string, proto3) ^:: basic_opt (4, (enum FieldType.from_int)) ^:: basic_opt (5, (message (fun t -> Imported'modules.Collections.Qdrant.PayloadIndexParams.from_proto t))) ^:: basic_opt (6, (message (fun t -> WriteOrdering.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DeleteFieldIndexCollection : sig
    val name': unit -> string
    type t = { collection_name: string; wait: bool option; field_name: string; ordering: WriteOrdering.t option } 
    val make : ?collection_name:string -> ?wait:bool -> ?field_name:string -> ?ordering:WriteOrdering.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.DeleteFieldIndexCollection"
    type t = { collection_name: string; wait: bool option; field_name: string; ordering: WriteOrdering.t option }
    let make =
      fun ?collection_name ?wait ?field_name ?ordering () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      let field_name = match field_name with Some v -> v | None -> {||} in
      { collection_name; wait; field_name; ordering }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; wait; field_name; ordering } -> f' [] collection_name wait field_name ordering in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, bool) ^:: basic (3, string, proto3) ^:: basic_opt (4, (message (fun t -> WriteOrdering.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name wait field_name ordering -> { collection_name; wait; field_name; ordering } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, bool) ^:: basic (3, string, proto3) ^:: basic_opt (4, (message (fun t -> WriteOrdering.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and PayloadIncludeSelector : sig
    val name': unit -> string
    type t = string list 
    val make : ?fields:string list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.PayloadIncludeSelector"
    type t = string list
    let make =
      fun ?fields () -> 
      let fields = match fields with Some v -> v | None -> [] in
      fields
    
    let to_proto =
      let apply = fun ~f:f' fields -> f' [] fields in
      let spec = Runtime'.Serialize.C.( repeated (1, string, packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions fields -> fields in
      let spec = Runtime'.Deserialize.C.( repeated (1, string, packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and PayloadExcludeSelector : sig
    val name': unit -> string
    type t = string list 
    val make : ?fields:string list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.PayloadExcludeSelector"
    type t = string list
    let make =
      fun ?fields () -> 
      let fields = match fields with Some v -> v | None -> [] in
      fields
    
    let to_proto =
      let apply = fun ~f:f' fields -> f' [] fields in
      let spec = Runtime'.Serialize.C.( repeated (1, string, packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions fields -> fields in
      let spec = Runtime'.Deserialize.C.( repeated (1, string, packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and WithPayloadSelector : sig
    val name': unit -> string
    type t = [ `not_set | `Enable of bool | `Include of PayloadIncludeSelector.t | `Exclude of PayloadExcludeSelector.t ] 
    val make : ?selector_options:[ `not_set | `Enable of bool | `Include of PayloadIncludeSelector.t | `Exclude of PayloadExcludeSelector.t ] -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.WithPayloadSelector"
    type t = [ `not_set | `Enable of bool | `Include of PayloadIncludeSelector.t | `Exclude of PayloadExcludeSelector.t ]
    let make =
      fun ?selector_options () -> 
      let selector_options = match selector_options with Some v -> v | None -> `not_set in
      selector_options
    
    let to_proto =
      let apply = fun ~f:f' selector_options -> f' [] selector_options in
      let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Enable v -> oneof_elem (1, bool, v) | `Include v -> oneof_elem (2, (message (fun t -> PayloadIncludeSelector.to_proto t)), v) | `Exclude v -> oneof_elem (3, (message (fun t -> PayloadExcludeSelector.to_proto t)), v))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions selector_options -> selector_options in
      let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, bool, fun v -> `Enable v); oneof_elem (2, (message (fun t -> PayloadIncludeSelector.from_proto t)), fun v -> `Include v); oneof_elem (3, (message (fun t -> PayloadExcludeSelector.from_proto t)), fun v -> `Exclude v) ]) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and NamedVectors : sig
    module rec VectorsEntry : sig
      val name': unit -> string
      type t = (string * Vector.t option) 
      val make : ?key:string -> ?value:Vector.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end
    val name': unit -> string
    type t = NamedVectors.VectorsEntry.t list 
    val make : ?vectors:NamedVectors.VectorsEntry.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    module rec VectorsEntry : sig
      val name': unit -> string
      type t = (string * Vector.t option) 
      val make : ?key:string -> ?value:Vector.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "points.qdrant.NamedVectors.VectorsEntry"
      type t = (string * Vector.t option)
      let make =
        fun ?key ?value () -> 
        let key = match key with Some v -> v | None -> {||} in
        (key, value)
      
      let to_proto =
        let apply = fun ~f:f' (key, value) -> f' [] key value in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Vector.to_proto t))) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions key value -> (key, value) in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Vector.from_proto t))) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    let name' () = "points.qdrant.NamedVectors"
    type t = NamedVectors.VectorsEntry.t list
    let make =
      fun ?vectors () -> 
      let vectors = match vectors with Some v -> v | None -> [] in
      vectors
    
    let to_proto =
      let apply = fun ~f:f' vectors -> f' [] vectors in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> NamedVectors.VectorsEntry.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions vectors -> vectors in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> NamedVectors.VectorsEntry.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and Vectors : sig
    val name': unit -> string
    type t = [ `not_set | `Vector of Vector.t | `Vectors of NamedVectors.t ] 
    val make : ?vectors_options:[ `not_set | `Vector of Vector.t | `Vectors of NamedVectors.t ] -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.Vectors"
    type t = [ `not_set | `Vector of Vector.t | `Vectors of NamedVectors.t ]
    let make =
      fun ?vectors_options () -> 
      let vectors_options = match vectors_options with Some v -> v | None -> `not_set in
      vectors_options
    
    let to_proto =
      let apply = fun ~f:f' vectors_options -> f' [] vectors_options in
      let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Vector v -> oneof_elem (1, (message (fun t -> Vector.to_proto t)), v) | `Vectors v -> oneof_elem (2, (message (fun t -> NamedVectors.to_proto t)), v))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions vectors_options -> vectors_options in
      let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> Vector.from_proto t)), fun v -> `Vector v); oneof_elem (2, (message (fun t -> NamedVectors.from_proto t)), fun v -> `Vectors v) ]) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and VectorsSelector : sig
    val name': unit -> string
    type t = string list 
    val make : ?names:string list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.VectorsSelector"
    type t = string list
    let make =
      fun ?names () -> 
      let names = match names with Some v -> v | None -> [] in
      names
    
    let to_proto =
      let apply = fun ~f:f' names -> f' [] names in
      let spec = Runtime'.Serialize.C.( repeated (1, string, packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions names -> names in
      let spec = Runtime'.Deserialize.C.( repeated (1, string, packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and WithVectorsSelector : sig
    val name': unit -> string
    type t = [ `not_set | `Enable of bool | `Include of VectorsSelector.t ] 
    val make : ?selector_options:[ `not_set | `Enable of bool | `Include of VectorsSelector.t ] -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.WithVectorsSelector"
    type t = [ `not_set | `Enable of bool | `Include of VectorsSelector.t ]
    let make =
      fun ?selector_options () -> 
      let selector_options = match selector_options with Some v -> v | None -> `not_set in
      selector_options
    
    let to_proto =
      let apply = fun ~f:f' selector_options -> f' [] selector_options in
      let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Enable v -> oneof_elem (1, bool, v) | `Include v -> oneof_elem (2, (message (fun t -> VectorsSelector.to_proto t)), v))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions selector_options -> selector_options in
      let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, bool, fun v -> `Enable v); oneof_elem (2, (message (fun t -> VectorsSelector.from_proto t)), fun v -> `Include v) ]) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and QuantizationSearchParams : sig
    val name': unit -> string
    type t = { ignore: bool option; rescore: bool option } 
    val make : ?ignore:bool -> ?rescore:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.QuantizationSearchParams"
    type t = { ignore: bool option; rescore: bool option }
    let make =
      fun ?ignore ?rescore () -> 
      
      { ignore; rescore }
    
    let to_proto =
      let apply = fun ~f:f' { ignore; rescore } -> f' [] ignore rescore in
      let spec = Runtime'.Serialize.C.( basic_opt (1, bool) ^:: basic_opt (2, bool) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions ignore rescore -> { ignore; rescore } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, bool) ^:: basic_opt (2, bool) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and SearchParams : sig
    val name': unit -> string
    type t = { hnsw_ef: int option; exact: bool option; quantization: QuantizationSearchParams.t option } 
    val make : ?hnsw_ef:int -> ?exact:bool -> ?quantization:QuantizationSearchParams.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.SearchParams"
    type t = { hnsw_ef: int option; exact: bool option; quantization: QuantizationSearchParams.t option }
    let make =
      fun ?hnsw_ef ?exact ?quantization () -> 
      
      { hnsw_ef; exact; quantization }
    
    let to_proto =
      let apply = fun ~f:f' { hnsw_ef; exact; quantization } -> f' [] hnsw_ef exact quantization in
      let spec = Runtime'.Serialize.C.( basic_opt (1, uint64_int) ^:: basic_opt (2, bool) ^:: basic_opt (3, (message (fun t -> QuantizationSearchParams.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions hnsw_ef exact quantization -> { hnsw_ef; exact; quantization } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, uint64_int) ^:: basic_opt (2, bool) ^:: basic_opt (3, (message (fun t -> QuantizationSearchParams.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and SearchPoints : sig
    val name': unit -> string
    type t = { collection_name: string; vector: float list; filter: Filter.t option; limit: int; with_payload: WithPayloadSelector.t option; params: SearchParams.t option; score_threshold: float option; offset: int option; vector_name: string option; with_vectors: WithVectorsSelector.t option; read_consistency: ReadConsistency.t option } 
    val make : ?collection_name:string -> ?vector:float list -> ?filter:Filter.t -> ?limit:int -> ?with_payload:WithPayloadSelector.t -> ?params:SearchParams.t -> ?score_threshold:float -> ?offset:int -> ?vector_name:string -> ?with_vectors:WithVectorsSelector.t -> ?read_consistency:ReadConsistency.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.SearchPoints"
    type t = { collection_name: string; vector: float list; filter: Filter.t option; limit: int; with_payload: WithPayloadSelector.t option; params: SearchParams.t option; score_threshold: float option; offset: int option; vector_name: string option; with_vectors: WithVectorsSelector.t option; read_consistency: ReadConsistency.t option }
    let make =
      fun ?collection_name ?vector ?filter ?limit ?with_payload ?params ?score_threshold ?offset ?vector_name ?with_vectors ?read_consistency () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      let vector = match vector with Some v -> v | None -> [] in
      let limit = match limit with Some v -> v | None -> 0 in
      { collection_name; vector; filter; limit; with_payload; params; score_threshold; offset; vector_name; with_vectors; read_consistency }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; vector; filter; limit; with_payload; params; score_threshold; offset; vector_name; with_vectors; read_consistency } -> f' [] collection_name vector filter limit with_payload params score_threshold offset vector_name with_vectors read_consistency in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, float, packed) ^:: basic_opt (3, (message (fun t -> Filter.to_proto t))) ^:: basic (4, uint64_int, proto3) ^:: basic_opt (6, (message (fun t -> WithPayloadSelector.to_proto t))) ^:: basic_opt (7, (message (fun t -> SearchParams.to_proto t))) ^:: basic_opt (8, float) ^:: basic_opt (9, uint64_int) ^:: basic_opt (10, string) ^:: basic_opt (11, (message (fun t -> WithVectorsSelector.to_proto t))) ^:: basic_opt (12, (message (fun t -> ReadConsistency.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name vector filter limit with_payload params score_threshold offset vector_name with_vectors read_consistency -> { collection_name; vector; filter; limit; with_payload; params; score_threshold; offset; vector_name; with_vectors; read_consistency } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, float, packed) ^:: basic_opt (3, (message (fun t -> Filter.from_proto t))) ^:: basic (4, uint64_int, proto3) ^:: basic_opt (6, (message (fun t -> WithPayloadSelector.from_proto t))) ^:: basic_opt (7, (message (fun t -> SearchParams.from_proto t))) ^:: basic_opt (8, float) ^:: basic_opt (9, uint64_int) ^:: basic_opt (10, string) ^:: basic_opt (11, (message (fun t -> WithVectorsSelector.from_proto t))) ^:: basic_opt (12, (message (fun t -> ReadConsistency.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and SearchBatchPoints : sig
    val name': unit -> string
    type t = { collection_name: string; search_points: SearchPoints.t list; read_consistency: ReadConsistency.t option } 
    val make : ?collection_name:string -> ?search_points:SearchPoints.t list -> ?read_consistency:ReadConsistency.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.SearchBatchPoints"
    type t = { collection_name: string; search_points: SearchPoints.t list; read_consistency: ReadConsistency.t option }
    let make =
      fun ?collection_name ?search_points ?read_consistency () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      let search_points = match search_points with Some v -> v | None -> [] in
      { collection_name; search_points; read_consistency }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; search_points; read_consistency } -> f' [] collection_name search_points read_consistency in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> SearchPoints.to_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> ReadConsistency.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name search_points read_consistency -> { collection_name; search_points; read_consistency } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> SearchPoints.from_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> ReadConsistency.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and SearchPointGroups : sig
    val name': unit -> string
    type t = { collection_name: string; vector: float list; filter: Filter.t option; limit: int; with_payload: WithPayloadSelector.t option; params: SearchParams.t option; score_threshold: float option; vector_name: string option; with_vectors: WithVectorsSelector.t option; group_by: string; group_size: int; read_consistency: ReadConsistency.t option } 
    val make : ?collection_name:string -> ?vector:float list -> ?filter:Filter.t -> ?limit:int -> ?with_payload:WithPayloadSelector.t -> ?params:SearchParams.t -> ?score_threshold:float -> ?vector_name:string -> ?with_vectors:WithVectorsSelector.t -> ?group_by:string -> ?group_size:int -> ?read_consistency:ReadConsistency.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.SearchPointGroups"
    type t = { collection_name: string; vector: float list; filter: Filter.t option; limit: int; with_payload: WithPayloadSelector.t option; params: SearchParams.t option; score_threshold: float option; vector_name: string option; with_vectors: WithVectorsSelector.t option; group_by: string; group_size: int; read_consistency: ReadConsistency.t option }
    let make =
      fun ?collection_name ?vector ?filter ?limit ?with_payload ?params ?score_threshold ?vector_name ?with_vectors ?group_by ?group_size ?read_consistency () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      let vector = match vector with Some v -> v | None -> [] in
      let limit = match limit with Some v -> v | None -> 0 in
      let group_by = match group_by with Some v -> v | None -> {||} in
      let group_size = match group_size with Some v -> v | None -> 0 in
      { collection_name; vector; filter; limit; with_payload; params; score_threshold; vector_name; with_vectors; group_by; group_size; read_consistency }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; vector; filter; limit; with_payload; params; score_threshold; vector_name; with_vectors; group_by; group_size; read_consistency } -> f' [] collection_name vector filter limit with_payload params score_threshold vector_name with_vectors group_by group_size read_consistency in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, float, packed) ^:: basic_opt (3, (message (fun t -> Filter.to_proto t))) ^:: basic (4, uint32_int, proto3) ^:: basic_opt (5, (message (fun t -> WithPayloadSelector.to_proto t))) ^:: basic_opt (6, (message (fun t -> SearchParams.to_proto t))) ^:: basic_opt (7, float) ^:: basic_opt (8, string) ^:: basic_opt (9, (message (fun t -> WithVectorsSelector.to_proto t))) ^:: basic (10, string, proto3) ^:: basic (11, uint32_int, proto3) ^:: basic_opt (12, (message (fun t -> ReadConsistency.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name vector filter limit with_payload params score_threshold vector_name with_vectors group_by group_size read_consistency -> { collection_name; vector; filter; limit; with_payload; params; score_threshold; vector_name; with_vectors; group_by; group_size; read_consistency } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, float, packed) ^:: basic_opt (3, (message (fun t -> Filter.from_proto t))) ^:: basic (4, uint32_int, proto3) ^:: basic_opt (5, (message (fun t -> WithPayloadSelector.from_proto t))) ^:: basic_opt (6, (message (fun t -> SearchParams.from_proto t))) ^:: basic_opt (7, float) ^:: basic_opt (8, string) ^:: basic_opt (9, (message (fun t -> WithVectorsSelector.from_proto t))) ^:: basic (10, string, proto3) ^:: basic (11, uint32_int, proto3) ^:: basic_opt (12, (message (fun t -> ReadConsistency.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ScrollPoints : sig
    val name': unit -> string
    type t = { collection_name: string; filter: Filter.t option; offset: PointId.t option; limit: int option; with_payload: WithPayloadSelector.t option; with_vectors: WithVectorsSelector.t option; read_consistency: ReadConsistency.t option } 
    val make : ?collection_name:string -> ?filter:Filter.t -> ?offset:PointId.t -> ?limit:int -> ?with_payload:WithPayloadSelector.t -> ?with_vectors:WithVectorsSelector.t -> ?read_consistency:ReadConsistency.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.ScrollPoints"
    type t = { collection_name: string; filter: Filter.t option; offset: PointId.t option; limit: int option; with_payload: WithPayloadSelector.t option; with_vectors: WithVectorsSelector.t option; read_consistency: ReadConsistency.t option }
    let make =
      fun ?collection_name ?filter ?offset ?limit ?with_payload ?with_vectors ?read_consistency () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      { collection_name; filter; offset; limit; with_payload; with_vectors; read_consistency }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; filter; offset; limit; with_payload; with_vectors; read_consistency } -> f' [] collection_name filter offset limit with_payload with_vectors read_consistency in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Filter.to_proto t))) ^:: basic_opt (3, (message (fun t -> PointId.to_proto t))) ^:: basic_opt (4, uint32_int) ^:: basic_opt (6, (message (fun t -> WithPayloadSelector.to_proto t))) ^:: basic_opt (7, (message (fun t -> WithVectorsSelector.to_proto t))) ^:: basic_opt (8, (message (fun t -> ReadConsistency.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name filter offset limit with_payload with_vectors read_consistency -> { collection_name; filter; offset; limit; with_payload; with_vectors; read_consistency } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Filter.from_proto t))) ^:: basic_opt (3, (message (fun t -> PointId.from_proto t))) ^:: basic_opt (4, uint32_int) ^:: basic_opt (6, (message (fun t -> WithPayloadSelector.from_proto t))) ^:: basic_opt (7, (message (fun t -> WithVectorsSelector.from_proto t))) ^:: basic_opt (8, (message (fun t -> ReadConsistency.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and LookupLocation : sig
    val name': unit -> string
    type t = { collection_name: string; vector_name: string option } 
    val make : ?collection_name:string -> ?vector_name:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.LookupLocation"
    type t = { collection_name: string; vector_name: string option }
    let make =
      fun ?collection_name ?vector_name () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      { collection_name; vector_name }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; vector_name } -> f' [] collection_name vector_name in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, string) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name vector_name -> { collection_name; vector_name } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, string) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RecommendPoints : sig
    val name': unit -> string
    type t = { collection_name: string; positive: PointId.t list; negative: PointId.t list; filter: Filter.t option; limit: int; with_payload: WithPayloadSelector.t option; params: SearchParams.t option; score_threshold: float option; offset: int option; using: string option; with_vectors: WithVectorsSelector.t option; lookup_from: LookupLocation.t option; read_consistency: ReadConsistency.t option } 
    val make : ?collection_name:string -> ?positive:PointId.t list -> ?negative:PointId.t list -> ?filter:Filter.t -> ?limit:int -> ?with_payload:WithPayloadSelector.t -> ?params:SearchParams.t -> ?score_threshold:float -> ?offset:int -> ?using:string -> ?with_vectors:WithVectorsSelector.t -> ?lookup_from:LookupLocation.t -> ?read_consistency:ReadConsistency.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.RecommendPoints"
    type t = { collection_name: string; positive: PointId.t list; negative: PointId.t list; filter: Filter.t option; limit: int; with_payload: WithPayloadSelector.t option; params: SearchParams.t option; score_threshold: float option; offset: int option; using: string option; with_vectors: WithVectorsSelector.t option; lookup_from: LookupLocation.t option; read_consistency: ReadConsistency.t option }
    let make =
      fun ?collection_name ?positive ?negative ?filter ?limit ?with_payload ?params ?score_threshold ?offset ?using ?with_vectors ?lookup_from ?read_consistency () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      let positive = match positive with Some v -> v | None -> [] in
      let negative = match negative with Some v -> v | None -> [] in
      let limit = match limit with Some v -> v | None -> 0 in
      { collection_name; positive; negative; filter; limit; with_payload; params; score_threshold; offset; using; with_vectors; lookup_from; read_consistency }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; positive; negative; filter; limit; with_payload; params; score_threshold; offset; using; with_vectors; lookup_from; read_consistency } -> f' [] collection_name positive negative filter limit with_payload params score_threshold offset using with_vectors lookup_from read_consistency in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> PointId.to_proto t)), not_packed) ^:: repeated (3, (message (fun t -> PointId.to_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> Filter.to_proto t))) ^:: basic (5, uint64_int, proto3) ^:: basic_opt (7, (message (fun t -> WithPayloadSelector.to_proto t))) ^:: basic_opt (8, (message (fun t -> SearchParams.to_proto t))) ^:: basic_opt (9, float) ^:: basic_opt (10, uint64_int) ^:: basic_opt (11, string) ^:: basic_opt (12, (message (fun t -> WithVectorsSelector.to_proto t))) ^:: basic_opt (13, (message (fun t -> LookupLocation.to_proto t))) ^:: basic_opt (14, (message (fun t -> ReadConsistency.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name positive negative filter limit with_payload params score_threshold offset using with_vectors lookup_from read_consistency -> { collection_name; positive; negative; filter; limit; with_payload; params; score_threshold; offset; using; with_vectors; lookup_from; read_consistency } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> PointId.from_proto t)), not_packed) ^:: repeated (3, (message (fun t -> PointId.from_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> Filter.from_proto t))) ^:: basic (5, uint64_int, proto3) ^:: basic_opt (7, (message (fun t -> WithPayloadSelector.from_proto t))) ^:: basic_opt (8, (message (fun t -> SearchParams.from_proto t))) ^:: basic_opt (9, float) ^:: basic_opt (10, uint64_int) ^:: basic_opt (11, string) ^:: basic_opt (12, (message (fun t -> WithVectorsSelector.from_proto t))) ^:: basic_opt (13, (message (fun t -> LookupLocation.from_proto t))) ^:: basic_opt (14, (message (fun t -> ReadConsistency.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RecommendBatchPoints : sig
    val name': unit -> string
    type t = { collection_name: string; recommend_points: RecommendPoints.t list; read_consistency: ReadConsistency.t option } 
    val make : ?collection_name:string -> ?recommend_points:RecommendPoints.t list -> ?read_consistency:ReadConsistency.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.RecommendBatchPoints"
    type t = { collection_name: string; recommend_points: RecommendPoints.t list; read_consistency: ReadConsistency.t option }
    let make =
      fun ?collection_name ?recommend_points ?read_consistency () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      let recommend_points = match recommend_points with Some v -> v | None -> [] in
      { collection_name; recommend_points; read_consistency }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; recommend_points; read_consistency } -> f' [] collection_name recommend_points read_consistency in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> RecommendPoints.to_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> ReadConsistency.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name recommend_points read_consistency -> { collection_name; recommend_points; read_consistency } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> RecommendPoints.from_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> ReadConsistency.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RecommendPointGroups : sig
    val name': unit -> string
    type t = { collection_name: string; positive: PointId.t list; negative: PointId.t list; filter: Filter.t option; limit: int; with_payload: WithPayloadSelector.t option; params: SearchParams.t option; score_threshold: float option; using: string option; with_vectors: WithVectorsSelector.t option; lookup_from: LookupLocation.t option; group_by: string; group_size: int; read_consistency: ReadConsistency.t option } 
    val make : ?collection_name:string -> ?positive:PointId.t list -> ?negative:PointId.t list -> ?filter:Filter.t -> ?limit:int -> ?with_payload:WithPayloadSelector.t -> ?params:SearchParams.t -> ?score_threshold:float -> ?using:string -> ?with_vectors:WithVectorsSelector.t -> ?lookup_from:LookupLocation.t -> ?group_by:string -> ?group_size:int -> ?read_consistency:ReadConsistency.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.RecommendPointGroups"
    type t = { collection_name: string; positive: PointId.t list; negative: PointId.t list; filter: Filter.t option; limit: int; with_payload: WithPayloadSelector.t option; params: SearchParams.t option; score_threshold: float option; using: string option; with_vectors: WithVectorsSelector.t option; lookup_from: LookupLocation.t option; group_by: string; group_size: int; read_consistency: ReadConsistency.t option }
    let make =
      fun ?collection_name ?positive ?negative ?filter ?limit ?with_payload ?params ?score_threshold ?using ?with_vectors ?lookup_from ?group_by ?group_size ?read_consistency () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      let positive = match positive with Some v -> v | None -> [] in
      let negative = match negative with Some v -> v | None -> [] in
      let limit = match limit with Some v -> v | None -> 0 in
      let group_by = match group_by with Some v -> v | None -> {||} in
      let group_size = match group_size with Some v -> v | None -> 0 in
      { collection_name; positive; negative; filter; limit; with_payload; params; score_threshold; using; with_vectors; lookup_from; group_by; group_size; read_consistency }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; positive; negative; filter; limit; with_payload; params; score_threshold; using; with_vectors; lookup_from; group_by; group_size; read_consistency } -> f' [] collection_name positive negative filter limit with_payload params score_threshold using with_vectors lookup_from group_by group_size read_consistency in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> PointId.to_proto t)), not_packed) ^:: repeated (3, (message (fun t -> PointId.to_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> Filter.to_proto t))) ^:: basic (5, uint32_int, proto3) ^:: basic_opt (6, (message (fun t -> WithPayloadSelector.to_proto t))) ^:: basic_opt (7, (message (fun t -> SearchParams.to_proto t))) ^:: basic_opt (8, float) ^:: basic_opt (9, string) ^:: basic_opt (10, (message (fun t -> WithVectorsSelector.to_proto t))) ^:: basic_opt (11, (message (fun t -> LookupLocation.to_proto t))) ^:: basic (12, string, proto3) ^:: basic (13, uint32_int, proto3) ^:: basic_opt (14, (message (fun t -> ReadConsistency.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name positive negative filter limit with_payload params score_threshold using with_vectors lookup_from group_by group_size read_consistency -> { collection_name; positive; negative; filter; limit; with_payload; params; score_threshold; using; with_vectors; lookup_from; group_by; group_size; read_consistency } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> PointId.from_proto t)), not_packed) ^:: repeated (3, (message (fun t -> PointId.from_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> Filter.from_proto t))) ^:: basic (5, uint32_int, proto3) ^:: basic_opt (6, (message (fun t -> WithPayloadSelector.from_proto t))) ^:: basic_opt (7, (message (fun t -> SearchParams.from_proto t))) ^:: basic_opt (8, float) ^:: basic_opt (9, string) ^:: basic_opt (10, (message (fun t -> WithVectorsSelector.from_proto t))) ^:: basic_opt (11, (message (fun t -> LookupLocation.from_proto t))) ^:: basic (12, string, proto3) ^:: basic (13, uint32_int, proto3) ^:: basic_opt (14, (message (fun t -> ReadConsistency.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CountPoints : sig
    val name': unit -> string
    type t = { collection_name: string; filter: Filter.t option; exact: bool option } 
    val make : ?collection_name:string -> ?filter:Filter.t -> ?exact:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.CountPoints"
    type t = { collection_name: string; filter: Filter.t option; exact: bool option }
    let make =
      fun ?collection_name ?filter ?exact () -> 
      let collection_name = match collection_name with Some v -> v | None -> {||} in
      { collection_name; filter; exact }
    
    let to_proto =
      let apply = fun ~f:f' { collection_name; filter; exact } -> f' [] collection_name filter exact in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Filter.to_proto t))) ^:: basic_opt (3, bool) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collection_name filter exact -> { collection_name; filter; exact } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Filter.from_proto t))) ^:: basic_opt (3, bool) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and PointsOperationResponse : sig
    val name': unit -> string
    type t = { result: UpdateResult.t option; time: float } 
    val make : ?result:UpdateResult.t -> ?time:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.PointsOperationResponse"
    type t = { result: UpdateResult.t option; time: float }
    let make =
      fun ?result ?time () -> 
      let time = match time with Some v -> v | None -> 0. in
      { result; time }
    
    let to_proto =
      let apply = fun ~f:f' { result; time } -> f' [] result time in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> UpdateResult.to_proto t))) ^:: basic (2, double, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions result time -> { result; time } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> UpdateResult.from_proto t))) ^:: basic (2, double, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and UpdateResult : sig
    val name': unit -> string
    type t = { operation_id: int; status: UpdateStatus.t } 
    val make : ?operation_id:int -> ?status:UpdateStatus.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.UpdateResult"
    type t = { operation_id: int; status: UpdateStatus.t }
    let make =
      fun ?operation_id ?status () -> 
      let operation_id = match operation_id with Some v -> v | None -> 0 in
      let status = match status with Some v -> v | None -> (UpdateStatus.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { operation_id; status }
    
    let to_proto =
      let apply = fun ~f:f' { operation_id; status } -> f' [] operation_id status in
      let spec = Runtime'.Serialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, (enum UpdateStatus.to_int), proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions operation_id status -> { operation_id; status } in
      let spec = Runtime'.Deserialize.C.( basic (1, uint64_int, proto3) ^:: basic (2, (enum UpdateStatus.from_int), proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ScoredPoint : sig
    module rec PayloadEntry : sig
      val name': unit -> string
      type t = (string * Imported'modules.Json_with_int.Qdrant.Value.t option) 
      val make : ?key:string -> ?value:Imported'modules.Json_with_int.Qdrant.Value.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end
    val name': unit -> string
    type t = { id: PointId.t option; payload: ScoredPoint.PayloadEntry.t list; score: float; version: int; vectors: Vectors.t option } 
    val make : ?id:PointId.t -> ?payload:ScoredPoint.PayloadEntry.t list -> ?score:float -> ?version:int -> ?vectors:Vectors.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    module rec PayloadEntry : sig
      val name': unit -> string
      type t = (string * Imported'modules.Json_with_int.Qdrant.Value.t option) 
      val make : ?key:string -> ?value:Imported'modules.Json_with_int.Qdrant.Value.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "points.qdrant.ScoredPoint.PayloadEntry"
      type t = (string * Imported'modules.Json_with_int.Qdrant.Value.t option)
      let make =
        fun ?key ?value () -> 
        let key = match key with Some v -> v | None -> {||} in
        (key, value)
      
      let to_proto =
        let apply = fun ~f:f' (key, value) -> f' [] key value in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Imported'modules.Json_with_int.Qdrant.Value.to_proto t))) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions key value -> (key, value) in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Imported'modules.Json_with_int.Qdrant.Value.from_proto t))) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    let name' () = "points.qdrant.ScoredPoint"
    type t = { id: PointId.t option; payload: ScoredPoint.PayloadEntry.t list; score: float; version: int; vectors: Vectors.t option }
    let make =
      fun ?id ?payload ?score ?version ?vectors () -> 
      let payload = match payload with Some v -> v | None -> [] in
      let score = match score with Some v -> v | None -> 0. in
      let version = match version with Some v -> v | None -> 0 in
      { id; payload; score; version; vectors }
    
    let to_proto =
      let apply = fun ~f:f' { id; payload; score; version; vectors } -> f' [] id payload score version vectors in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> PointId.to_proto t))) ^:: repeated (2, (message (fun t -> ScoredPoint.PayloadEntry.to_proto t)), not_packed) ^:: basic (3, float, proto3) ^:: basic (5, uint64_int, proto3) ^:: basic_opt (6, (message (fun t -> Vectors.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions id payload score version vectors -> { id; payload; score; version; vectors } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> PointId.from_proto t))) ^:: repeated (2, (message (fun t -> ScoredPoint.PayloadEntry.from_proto t)), not_packed) ^:: basic (3, float, proto3) ^:: basic (5, uint64_int, proto3) ^:: basic_opt (6, (message (fun t -> Vectors.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and GroupId : sig
    val name': unit -> string
    type t = [ `not_set | `Unsigned_value of int | `Integer_value of int | `String_value of string ] 
    val make : ?kind:[ `not_set | `Unsigned_value of int | `Integer_value of int | `String_value of string ] -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.GroupId"
    type t = [ `not_set | `Unsigned_value of int | `Integer_value of int | `String_value of string ]
    let make =
      fun ?kind () -> 
      let kind = match kind with Some v -> v | None -> `not_set in
      kind
    
    let to_proto =
      let apply = fun ~f:f' kind -> f' [] kind in
      let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Unsigned_value v -> oneof_elem (1, uint64_int, v) | `Integer_value v -> oneof_elem (2, int64_int, v) | `String_value v -> oneof_elem (3, string, v))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions kind -> kind in
      let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, uint64_int, fun v -> `Unsigned_value v); oneof_elem (2, int64_int, fun v -> `Integer_value v); oneof_elem (3, string, fun v -> `String_value v) ]) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and PointGroup : sig
    val name': unit -> string
    type t = { id: GroupId.t option; hits: ScoredPoint.t list } 
    val make : ?id:GroupId.t -> ?hits:ScoredPoint.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.PointGroup"
    type t = { id: GroupId.t option; hits: ScoredPoint.t list }
    let make =
      fun ?id ?hits () -> 
      let hits = match hits with Some v -> v | None -> [] in
      { id; hits }
    
    let to_proto =
      let apply = fun ~f:f' { id; hits } -> f' [] id hits in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> GroupId.to_proto t))) ^:: repeated (2, (message (fun t -> ScoredPoint.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions id hits -> { id; hits } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> GroupId.from_proto t))) ^:: repeated (2, (message (fun t -> ScoredPoint.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and GroupsResult : sig
    val name': unit -> string
    type t = PointGroup.t list 
    val make : ?groups:PointGroup.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.GroupsResult"
    type t = PointGroup.t list
    let make =
      fun ?groups () -> 
      let groups = match groups with Some v -> v | None -> [] in
      groups
    
    let to_proto =
      let apply = fun ~f:f' groups -> f' [] groups in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> PointGroup.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions groups -> groups in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> PointGroup.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and SearchResponse : sig
    val name': unit -> string
    type t = { result: ScoredPoint.t list; time: float } 
    val make : ?result:ScoredPoint.t list -> ?time:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.SearchResponse"
    type t = { result: ScoredPoint.t list; time: float }
    let make =
      fun ?result ?time () -> 
      let result = match result with Some v -> v | None -> [] in
      let time = match time with Some v -> v | None -> 0. in
      { result; time }
    
    let to_proto =
      let apply = fun ~f:f' { result; time } -> f' [] result time in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> ScoredPoint.to_proto t)), not_packed) ^:: basic (2, double, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions result time -> { result; time } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> ScoredPoint.from_proto t)), not_packed) ^:: basic (2, double, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and BatchResult : sig
    val name': unit -> string
    type t = ScoredPoint.t list 
    val make : ?result:ScoredPoint.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.BatchResult"
    type t = ScoredPoint.t list
    let make =
      fun ?result () -> 
      let result = match result with Some v -> v | None -> [] in
      result
    
    let to_proto =
      let apply = fun ~f:f' result -> f' [] result in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> ScoredPoint.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions result -> result in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> ScoredPoint.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and SearchBatchResponse : sig
    val name': unit -> string
    type t = { result: BatchResult.t list; time: float } 
    val make : ?result:BatchResult.t list -> ?time:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.SearchBatchResponse"
    type t = { result: BatchResult.t list; time: float }
    let make =
      fun ?result ?time () -> 
      let result = match result with Some v -> v | None -> [] in
      let time = match time with Some v -> v | None -> 0. in
      { result; time }
    
    let to_proto =
      let apply = fun ~f:f' { result; time } -> f' [] result time in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> BatchResult.to_proto t)), not_packed) ^:: basic (2, double, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions result time -> { result; time } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> BatchResult.from_proto t)), not_packed) ^:: basic (2, double, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and SearchGroupsResponse : sig
    val name': unit -> string
    type t = { result: GroupsResult.t option; time: float } 
    val make : ?result:GroupsResult.t -> ?time:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.SearchGroupsResponse"
    type t = { result: GroupsResult.t option; time: float }
    let make =
      fun ?result ?time () -> 
      let time = match time with Some v -> v | None -> 0. in
      { result; time }
    
    let to_proto =
      let apply = fun ~f:f' { result; time } -> f' [] result time in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> GroupsResult.to_proto t))) ^:: basic (2, double, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions result time -> { result; time } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> GroupsResult.from_proto t))) ^:: basic (2, double, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CountResponse : sig
    val name': unit -> string
    type t = { result: CountResult.t option; time: float } 
    val make : ?result:CountResult.t -> ?time:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.CountResponse"
    type t = { result: CountResult.t option; time: float }
    let make =
      fun ?result ?time () -> 
      let time = match time with Some v -> v | None -> 0. in
      { result; time }
    
    let to_proto =
      let apply = fun ~f:f' { result; time } -> f' [] result time in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> CountResult.to_proto t))) ^:: basic (2, double, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions result time -> { result; time } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> CountResult.from_proto t))) ^:: basic (2, double, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ScrollResponse : sig
    val name': unit -> string
    type t = { next_page_offset: PointId.t option; result: RetrievedPoint.t list; time: float } 
    val make : ?next_page_offset:PointId.t -> ?result:RetrievedPoint.t list -> ?time:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.ScrollResponse"
    type t = { next_page_offset: PointId.t option; result: RetrievedPoint.t list; time: float }
    let make =
      fun ?next_page_offset ?result ?time () -> 
      let result = match result with Some v -> v | None -> [] in
      let time = match time with Some v -> v | None -> 0. in
      { next_page_offset; result; time }
    
    let to_proto =
      let apply = fun ~f:f' { next_page_offset; result; time } -> f' [] next_page_offset result time in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> PointId.to_proto t))) ^:: repeated (2, (message (fun t -> RetrievedPoint.to_proto t)), not_packed) ^:: basic (3, double, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions next_page_offset result time -> { next_page_offset; result; time } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> PointId.from_proto t))) ^:: repeated (2, (message (fun t -> RetrievedPoint.from_proto t)), not_packed) ^:: basic (3, double, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CountResult : sig
    val name': unit -> string
    type t = int 
    val make : ?count:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.CountResult"
    type t = int
    let make =
      fun ?count () -> 
      let count = match count with Some v -> v | None -> 0 in
      count
    
    let to_proto =
      let apply = fun ~f:f' count -> f' [] count in
      let spec = Runtime'.Serialize.C.( basic (1, uint64_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions count -> count in
      let spec = Runtime'.Deserialize.C.( basic (1, uint64_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RetrievedPoint : sig
    module rec PayloadEntry : sig
      val name': unit -> string
      type t = (string * Imported'modules.Json_with_int.Qdrant.Value.t option) 
      val make : ?key:string -> ?value:Imported'modules.Json_with_int.Qdrant.Value.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end
    val name': unit -> string
    type t = { id: PointId.t option; payload: RetrievedPoint.PayloadEntry.t list; vectors: Vectors.t option } 
    val make : ?id:PointId.t -> ?payload:RetrievedPoint.PayloadEntry.t list -> ?vectors:Vectors.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    module rec PayloadEntry : sig
      val name': unit -> string
      type t = (string * Imported'modules.Json_with_int.Qdrant.Value.t option) 
      val make : ?key:string -> ?value:Imported'modules.Json_with_int.Qdrant.Value.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "points.qdrant.RetrievedPoint.PayloadEntry"
      type t = (string * Imported'modules.Json_with_int.Qdrant.Value.t option)
      let make =
        fun ?key ?value () -> 
        let key = match key with Some v -> v | None -> {||} in
        (key, value)
      
      let to_proto =
        let apply = fun ~f:f' (key, value) -> f' [] key value in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Imported'modules.Json_with_int.Qdrant.Value.to_proto t))) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions key value -> (key, value) in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Imported'modules.Json_with_int.Qdrant.Value.from_proto t))) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    let name' () = "points.qdrant.RetrievedPoint"
    type t = { id: PointId.t option; payload: RetrievedPoint.PayloadEntry.t list; vectors: Vectors.t option }
    let make =
      fun ?id ?payload ?vectors () -> 
      let payload = match payload with Some v -> v | None -> [] in
      { id; payload; vectors }
    
    let to_proto =
      let apply = fun ~f:f' { id; payload; vectors } -> f' [] id payload vectors in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> PointId.to_proto t))) ^:: repeated (2, (message (fun t -> RetrievedPoint.PayloadEntry.to_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> Vectors.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions id payload vectors -> { id; payload; vectors } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> PointId.from_proto t))) ^:: repeated (2, (message (fun t -> RetrievedPoint.PayloadEntry.from_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> Vectors.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and GetResponse : sig
    val name': unit -> string
    type t = { result: RetrievedPoint.t list; time: float } 
    val make : ?result:RetrievedPoint.t list -> ?time:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.GetResponse"
    type t = { result: RetrievedPoint.t list; time: float }
    let make =
      fun ?result ?time () -> 
      let result = match result with Some v -> v | None -> [] in
      let time = match time with Some v -> v | None -> 0. in
      { result; time }
    
    let to_proto =
      let apply = fun ~f:f' { result; time } -> f' [] result time in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> RetrievedPoint.to_proto t)), not_packed) ^:: basic (2, double, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions result time -> { result; time } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> RetrievedPoint.from_proto t)), not_packed) ^:: basic (2, double, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RecommendResponse : sig
    val name': unit -> string
    type t = { result: ScoredPoint.t list; time: float } 
    val make : ?result:ScoredPoint.t list -> ?time:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.RecommendResponse"
    type t = { result: ScoredPoint.t list; time: float }
    let make =
      fun ?result ?time () -> 
      let result = match result with Some v -> v | None -> [] in
      let time = match time with Some v -> v | None -> 0. in
      { result; time }
    
    let to_proto =
      let apply = fun ~f:f' { result; time } -> f' [] result time in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> ScoredPoint.to_proto t)), not_packed) ^:: basic (2, double, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions result time -> { result; time } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> ScoredPoint.from_proto t)), not_packed) ^:: basic (2, double, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RecommendBatchResponse : sig
    val name': unit -> string
    type t = { result: BatchResult.t list; time: float } 
    val make : ?result:BatchResult.t list -> ?time:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.RecommendBatchResponse"
    type t = { result: BatchResult.t list; time: float }
    let make =
      fun ?result ?time () -> 
      let result = match result with Some v -> v | None -> [] in
      let time = match time with Some v -> v | None -> 0. in
      { result; time }
    
    let to_proto =
      let apply = fun ~f:f' { result; time } -> f' [] result time in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> BatchResult.to_proto t)), not_packed) ^:: basic (2, double, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions result time -> { result; time } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> BatchResult.from_proto t)), not_packed) ^:: basic (2, double, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RecommendGroupsResponse : sig
    val name': unit -> string
    type t = { result: GroupsResult.t option; time: float } 
    val make : ?result:GroupsResult.t -> ?time:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.RecommendGroupsResponse"
    type t = { result: GroupsResult.t option; time: float }
    let make =
      fun ?result ?time () -> 
      let time = match time with Some v -> v | None -> 0. in
      { result; time }
    
    let to_proto =
      let apply = fun ~f:f' { result; time } -> f' [] result time in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> GroupsResult.to_proto t))) ^:: basic (2, double, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions result time -> { result; time } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> GroupsResult.from_proto t))) ^:: basic (2, double, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and Filter : sig
    val name': unit -> string
    type t = { should: Condition.t list; must: Condition.t list; must_not: Condition.t list } 
    val make : ?should:Condition.t list -> ?must:Condition.t list -> ?must_not:Condition.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.Filter"
    type t = { should: Condition.t list; must: Condition.t list; must_not: Condition.t list }
    let make =
      fun ?should ?must ?must_not () -> 
      let should = match should with Some v -> v | None -> [] in
      let must = match must with Some v -> v | None -> [] in
      let must_not = match must_not with Some v -> v | None -> [] in
      { should; must; must_not }
    
    let to_proto =
      let apply = fun ~f:f' { should; must; must_not } -> f' [] should must must_not in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Condition.to_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Condition.to_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Condition.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions should must must_not -> { should; must; must_not } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Condition.from_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Condition.from_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Condition.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and Condition : sig
    val name': unit -> string
    type t = [ `not_set | `Field of FieldCondition.t | `Is_empty of IsEmptyCondition.t | `Has_id of HasIdCondition.t | `Filter of Filter.t | `Is_null of IsNullCondition.t | `Nested of NestedCondition.t ] 
    val make : ?condition_one_of:[ `not_set | `Field of FieldCondition.t | `Is_empty of IsEmptyCondition.t | `Has_id of HasIdCondition.t | `Filter of Filter.t | `Is_null of IsNullCondition.t | `Nested of NestedCondition.t ] -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.Condition"
    type t = [ `not_set | `Field of FieldCondition.t | `Is_empty of IsEmptyCondition.t | `Has_id of HasIdCondition.t | `Filter of Filter.t | `Is_null of IsNullCondition.t | `Nested of NestedCondition.t ]
    let make =
      fun ?condition_one_of () -> 
      let condition_one_of = match condition_one_of with Some v -> v | None -> `not_set in
      condition_one_of
    
    let to_proto =
      let apply = fun ~f:f' condition_one_of -> f' [] condition_one_of in
      let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Field v -> oneof_elem (1, (message (fun t -> FieldCondition.to_proto t)), v) | `Is_empty v -> oneof_elem (2, (message (fun t -> IsEmptyCondition.to_proto t)), v) | `Has_id v -> oneof_elem (3, (message (fun t -> HasIdCondition.to_proto t)), v) | `Filter v -> oneof_elem (4, (message (fun t -> Filter.to_proto t)), v) | `Is_null v -> oneof_elem (5, (message (fun t -> IsNullCondition.to_proto t)), v) | `Nested v -> oneof_elem (6, (message (fun t -> NestedCondition.to_proto t)), v))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions condition_one_of -> condition_one_of in
      let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> FieldCondition.from_proto t)), fun v -> `Field v); oneof_elem (2, (message (fun t -> IsEmptyCondition.from_proto t)), fun v -> `Is_empty v); oneof_elem (3, (message (fun t -> HasIdCondition.from_proto t)), fun v -> `Has_id v); oneof_elem (4, (message (fun t -> Filter.from_proto t)), fun v -> `Filter v); oneof_elem (5, (message (fun t -> IsNullCondition.from_proto t)), fun v -> `Is_null v); oneof_elem (6, (message (fun t -> NestedCondition.from_proto t)), fun v -> `Nested v) ]) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and IsEmptyCondition : sig
    val name': unit -> string
    type t = string 
    val make : ?key:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.IsEmptyCondition"
    type t = string
    let make =
      fun ?key () -> 
      let key = match key with Some v -> v | None -> {||} in
      key
    
    let to_proto =
      let apply = fun ~f:f' key -> f' [] key in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions key -> key in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and IsNullCondition : sig
    val name': unit -> string
    type t = string 
    val make : ?key:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.IsNullCondition"
    type t = string
    let make =
      fun ?key () -> 
      let key = match key with Some v -> v | None -> {||} in
      key
    
    let to_proto =
      let apply = fun ~f:f' key -> f' [] key in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions key -> key in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and HasIdCondition : sig
    val name': unit -> string
    type t = PointId.t list 
    val make : ?has_id:PointId.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.HasIdCondition"
    type t = PointId.t list
    let make =
      fun ?has_id () -> 
      let has_id = match has_id with Some v -> v | None -> [] in
      has_id
    
    let to_proto =
      let apply = fun ~f:f' has_id -> f' [] has_id in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> PointId.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions has_id -> has_id in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> PointId.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and NestedCondition : sig
    val name': unit -> string
    type t = { key: string; filter: Filter.t option } 
    val make : ?key:string -> ?filter:Filter.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.NestedCondition"
    type t = { key: string; filter: Filter.t option }
    let make =
      fun ?key ?filter () -> 
      let key = match key with Some v -> v | None -> {||} in
      { key; filter }
    
    let to_proto =
      let apply = fun ~f:f' { key; filter } -> f' [] key filter in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Filter.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions key filter -> { key; filter } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Filter.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and FieldCondition : sig
    val name': unit -> string
    type t = { key: string; match': Match.t option; range: Range.t option; geo_bounding_box: GeoBoundingBox.t option; geo_radius: GeoRadius.t option; values_count: ValuesCount.t option } 
    val make : ?key:string -> ?match':Match.t -> ?range:Range.t -> ?geo_bounding_box:GeoBoundingBox.t -> ?geo_radius:GeoRadius.t -> ?values_count:ValuesCount.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.FieldCondition"
    type t = { key: string; match': Match.t option; range: Range.t option; geo_bounding_box: GeoBoundingBox.t option; geo_radius: GeoRadius.t option; values_count: ValuesCount.t option }
    let make =
      fun ?key ?match' ?range ?geo_bounding_box ?geo_radius ?values_count () -> 
      let key = match key with Some v -> v | None -> {||} in
      { key; match'; range; geo_bounding_box; geo_radius; values_count }
    
    let to_proto =
      let apply = fun ~f:f' { key; match'; range; geo_bounding_box; geo_radius; values_count } -> f' [] key match' range geo_bounding_box geo_radius values_count in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Match.to_proto t))) ^:: basic_opt (3, (message (fun t -> Range.to_proto t))) ^:: basic_opt (4, (message (fun t -> GeoBoundingBox.to_proto t))) ^:: basic_opt (5, (message (fun t -> GeoRadius.to_proto t))) ^:: basic_opt (6, (message (fun t -> ValuesCount.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions key match' range geo_bounding_box geo_radius values_count -> { key; match'; range; geo_bounding_box; geo_radius; values_count } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Match.from_proto t))) ^:: basic_opt (3, (message (fun t -> Range.from_proto t))) ^:: basic_opt (4, (message (fun t -> GeoBoundingBox.from_proto t))) ^:: basic_opt (5, (message (fun t -> GeoRadius.from_proto t))) ^:: basic_opt (6, (message (fun t -> ValuesCount.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and Match : sig
    val name': unit -> string
    type t = [ `not_set | `Keyword of string | `Integer of int | `Boolean of bool | `Text of string | `Keywords of RepeatedStrings.t | `Integers of RepeatedIntegers.t | `Except_integers of RepeatedIntegers.t | `Except_keywords of RepeatedStrings.t ] 
    val make : ?match_value:[ `not_set | `Keyword of string | `Integer of int | `Boolean of bool | `Text of string | `Keywords of RepeatedStrings.t | `Integers of RepeatedIntegers.t | `Except_integers of RepeatedIntegers.t | `Except_keywords of RepeatedStrings.t ] -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.Match"
    type t = [ `not_set | `Keyword of string | `Integer of int | `Boolean of bool | `Text of string | `Keywords of RepeatedStrings.t | `Integers of RepeatedIntegers.t | `Except_integers of RepeatedIntegers.t | `Except_keywords of RepeatedStrings.t ]
    let make =
      fun ?match_value () -> 
      let match_value = match match_value with Some v -> v | None -> `not_set in
      match_value
    
    let to_proto =
      let apply = fun ~f:f' match_value -> f' [] match_value in
      let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Keyword v -> oneof_elem (1, string, v) | `Integer v -> oneof_elem (2, int64_int, v) | `Boolean v -> oneof_elem (3, bool, v) | `Text v -> oneof_elem (4, string, v) | `Keywords v -> oneof_elem (5, (message (fun t -> RepeatedStrings.to_proto t)), v) | `Integers v -> oneof_elem (6, (message (fun t -> RepeatedIntegers.to_proto t)), v) | `Except_integers v -> oneof_elem (7, (message (fun t -> RepeatedIntegers.to_proto t)), v) | `Except_keywords v -> oneof_elem (8, (message (fun t -> RepeatedStrings.to_proto t)), v))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions match_value -> match_value in
      let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, string, fun v -> `Keyword v); oneof_elem (2, int64_int, fun v -> `Integer v); oneof_elem (3, bool, fun v -> `Boolean v); oneof_elem (4, string, fun v -> `Text v); oneof_elem (5, (message (fun t -> RepeatedStrings.from_proto t)), fun v -> `Keywords v); oneof_elem (6, (message (fun t -> RepeatedIntegers.from_proto t)), fun v -> `Integers v); oneof_elem (7, (message (fun t -> RepeatedIntegers.from_proto t)), fun v -> `Except_integers v); oneof_elem (8, (message (fun t -> RepeatedStrings.from_proto t)), fun v -> `Except_keywords v) ]) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RepeatedStrings : sig
    val name': unit -> string
    type t = string list 
    val make : ?strings:string list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.RepeatedStrings"
    type t = string list
    let make =
      fun ?strings () -> 
      let strings = match strings with Some v -> v | None -> [] in
      strings
    
    let to_proto =
      let apply = fun ~f:f' strings -> f' [] strings in
      let spec = Runtime'.Serialize.C.( repeated (1, string, packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions strings -> strings in
      let spec = Runtime'.Deserialize.C.( repeated (1, string, packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RepeatedIntegers : sig
    val name': unit -> string
    type t = int list 
    val make : ?integers:int list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.RepeatedIntegers"
    type t = int list
    let make =
      fun ?integers () -> 
      let integers = match integers with Some v -> v | None -> [] in
      integers
    
    let to_proto =
      let apply = fun ~f:f' integers -> f' [] integers in
      let spec = Runtime'.Serialize.C.( repeated (1, int64_int, packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions integers -> integers in
      let spec = Runtime'.Deserialize.C.( repeated (1, int64_int, packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and Range : sig
    val name': unit -> string
    type t = { lt: float option; gt: float option; gte: float option; lte: float option } 
    val make : ?lt:float -> ?gt:float -> ?gte:float -> ?lte:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.Range"
    type t = { lt: float option; gt: float option; gte: float option; lte: float option }
    let make =
      fun ?lt ?gt ?gte ?lte () -> 
      
      { lt; gt; gte; lte }
    
    let to_proto =
      let apply = fun ~f:f' { lt; gt; gte; lte } -> f' [] lt gt gte lte in
      let spec = Runtime'.Serialize.C.( basic_opt (1, double) ^:: basic_opt (2, double) ^:: basic_opt (3, double) ^:: basic_opt (4, double) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions lt gt gte lte -> { lt; gt; gte; lte } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, double) ^:: basic_opt (2, double) ^:: basic_opt (3, double) ^:: basic_opt (4, double) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and GeoBoundingBox : sig
    val name': unit -> string
    type t = { top_left: GeoPoint.t option; bottom_right: GeoPoint.t option } 
    val make : ?top_left:GeoPoint.t -> ?bottom_right:GeoPoint.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.GeoBoundingBox"
    type t = { top_left: GeoPoint.t option; bottom_right: GeoPoint.t option }
    let make =
      fun ?top_left ?bottom_right () -> 
      
      { top_left; bottom_right }
    
    let to_proto =
      let apply = fun ~f:f' { top_left; bottom_right } -> f' [] top_left bottom_right in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> GeoPoint.to_proto t))) ^:: basic_opt (2, (message (fun t -> GeoPoint.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions top_left bottom_right -> { top_left; bottom_right } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> GeoPoint.from_proto t))) ^:: basic_opt (2, (message (fun t -> GeoPoint.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and GeoRadius : sig
    val name': unit -> string
    type t = { center: GeoPoint.t option; radius: float } 
    val make : ?center:GeoPoint.t -> ?radius:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.GeoRadius"
    type t = { center: GeoPoint.t option; radius: float }
    let make =
      fun ?center ?radius () -> 
      let radius = match radius with Some v -> v | None -> 0. in
      { center; radius }
    
    let to_proto =
      let apply = fun ~f:f' { center; radius } -> f' [] center radius in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> GeoPoint.to_proto t))) ^:: basic (2, float, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions center radius -> { center; radius } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> GeoPoint.from_proto t))) ^:: basic (2, float, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ValuesCount : sig
    val name': unit -> string
    type t = { lt: int option; gt: int option; gte: int option; lte: int option } 
    val make : ?lt:int -> ?gt:int -> ?gte:int -> ?lte:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.ValuesCount"
    type t = { lt: int option; gt: int option; gte: int option; lte: int option }
    let make =
      fun ?lt ?gt ?gte ?lte () -> 
      
      { lt; gt; gte; lte }
    
    let to_proto =
      let apply = fun ~f:f' { lt; gt; gte; lte } -> f' [] lt gt gte lte in
      let spec = Runtime'.Serialize.C.( basic_opt (1, uint64_int) ^:: basic_opt (2, uint64_int) ^:: basic_opt (3, uint64_int) ^:: basic_opt (4, uint64_int) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions lt gt gte lte -> { lt; gt; gte; lte } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, uint64_int) ^:: basic_opt (2, uint64_int) ^:: basic_opt (3, uint64_int) ^:: basic_opt (4, uint64_int) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and PointsSelector : sig
    val name': unit -> string
    type t = [ `not_set | `Points of PointsIdsList.t | `Filter of Filter.t ] 
    val make : ?points_selector_one_of:[ `not_set | `Points of PointsIdsList.t | `Filter of Filter.t ] -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.PointsSelector"
    type t = [ `not_set | `Points of PointsIdsList.t | `Filter of Filter.t ]
    let make =
      fun ?points_selector_one_of () -> 
      let points_selector_one_of = match points_selector_one_of with Some v -> v | None -> `not_set in
      points_selector_one_of
    
    let to_proto =
      let apply = fun ~f:f' points_selector_one_of -> f' [] points_selector_one_of in
      let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Points v -> oneof_elem (1, (message (fun t -> PointsIdsList.to_proto t)), v) | `Filter v -> oneof_elem (2, (message (fun t -> Filter.to_proto t)), v))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions points_selector_one_of -> points_selector_one_of in
      let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> PointsIdsList.from_proto t)), fun v -> `Points v); oneof_elem (2, (message (fun t -> Filter.from_proto t)), fun v -> `Filter v) ]) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and PointsIdsList : sig
    val name': unit -> string
    type t = PointId.t list 
    val make : ?ids:PointId.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.PointsIdsList"
    type t = PointId.t list
    let make =
      fun ?ids () -> 
      let ids = match ids with Some v -> v | None -> [] in
      ids
    
    let to_proto =
      let apply = fun ~f:f' ids -> f' [] ids in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> PointId.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions ids -> ids in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> PointId.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and PointStruct : sig
    module rec PayloadEntry : sig
      val name': unit -> string
      type t = (string * Imported'modules.Json_with_int.Qdrant.Value.t option) 
      val make : ?key:string -> ?value:Imported'modules.Json_with_int.Qdrant.Value.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end
    val name': unit -> string
    type t = { id: PointId.t option; payload: PointStruct.PayloadEntry.t list; vectors: Vectors.t option } 
    val make : ?id:PointId.t -> ?payload:PointStruct.PayloadEntry.t list -> ?vectors:Vectors.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    module rec PayloadEntry : sig
      val name': unit -> string
      type t = (string * Imported'modules.Json_with_int.Qdrant.Value.t option) 
      val make : ?key:string -> ?value:Imported'modules.Json_with_int.Qdrant.Value.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct 
      let name' () = "points.qdrant.PointStruct.PayloadEntry"
      type t = (string * Imported'modules.Json_with_int.Qdrant.Value.t option)
      let make =
        fun ?key ?value () -> 
        let key = match key with Some v -> v | None -> {||} in
        (key, value)
      
      let to_proto =
        let apply = fun ~f:f' (key, value) -> f' [] key value in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Imported'modules.Json_with_int.Qdrant.Value.to_proto t))) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t
      
      let from_proto =
        let constructor = fun _extensions key value -> (key, value) in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Imported'modules.Json_with_int.Qdrant.Value.from_proto t))) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error
      
    end
    let name' () = "points.qdrant.PointStruct"
    type t = { id: PointId.t option; payload: PointStruct.PayloadEntry.t list; vectors: Vectors.t option }
    let make =
      fun ?id ?payload ?vectors () -> 
      let payload = match payload with Some v -> v | None -> [] in
      { id; payload; vectors }
    
    let to_proto =
      let apply = fun ~f:f' { id; payload; vectors } -> f' [] id payload vectors in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> PointId.to_proto t))) ^:: repeated (3, (message (fun t -> PointStruct.PayloadEntry.to_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> Vectors.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions id payload vectors -> { id; payload; vectors } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> PointId.from_proto t))) ^:: repeated (3, (message (fun t -> PointStruct.PayloadEntry.from_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> Vectors.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and GeoPoint : sig
    val name': unit -> string
    type t = { lon: float; lat: float } 
    val make : ?lon:float -> ?lat:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "points.qdrant.GeoPoint"
    type t = { lon: float; lat: float }
    let make =
      fun ?lon ?lat () -> 
      let lon = match lon with Some v -> v | None -> 0. in
      let lat = match lat with Some v -> v | None -> 0. in
      { lon; lat }
    
    let to_proto =
      let apply = fun ~f:f' { lon; lat } -> f' [] lon lat in
      let spec = Runtime'.Serialize.C.( basic (1, double, proto3) ^:: basic (2, double, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions lon lat -> { lon; lat } in
      let spec = Runtime'.Deserialize.C.( basic (1, double, proto3) ^:: basic (2, double, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
end